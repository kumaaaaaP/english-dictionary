<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>将棋</title>
    <style>
        body {
            font-family: 'BIZ UDGothic', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        h1 {
            color: #333;
            margin-bottom: 20px;
        }
        #game-area {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        #player2-hand {
            width: 80px;
            height: 540px;
            border: 2px solid #8B4513;
            background-color: #DEB887;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            gap: 5px;
        }
        #player1-hand {
            width: 80px;
            height: 540px;
            border: 2px solid #8B4513;
            background-color: #DEB887;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            gap: 5px;
        }
        .hand-piece {
            width: 55px;
            height: 55px;
            background-color: #D2B48C;
            border: 1px solid #8B4513;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            font-weight: bold;
            cursor: pointer;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
            box-shadow: 1px 1px 3px rgba(0,0,0,0.2);
            user-select: none;
            writing-mode: vertical-lr;
            text-orientation: upright;
            flex-shrink: 0;
        }
        .hand-piece.player1 {
            color: #333;
            transform: rotate(0deg);
        }
        .hand-piece.player2 {
            transform: rotate(180deg);
            color: #333;
        }
        #shogi-board {
            display: grid;
            grid-template-columns: repeat(9, 60px);
            grid-template-rows: repeat(9, 60px);
            width: 540px;
            height: 540px;
            border: 2px solid #8B4513;
            background-color: #DEB887;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.3);
        }
        .square {
            width: 60px;
            height: 60px;
            border: 1px solid #A0522D;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .piece {
            width: 55px;
            height: 55px;
            background-color: #D2B48C;
            border: 1px solid #8B4513;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8em;
            font-weight: bold;
            cursor: pointer;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
            box-shadow: 1px 1px 3px rgba(0,0,0,0.2);
            user-select: none;
            writing-mode: vertical-lr;
            text-orientation: upright;
        }
        .piece.player1 {
            color: #333;
            transform: rotate(0deg);
        }
        .piece.player2 {
            color: #333;
            transform: rotate(180deg);
        }
        .piece.promoted {
            background-color: #FFDDC1;
            color: #CC0000;
            border: 2px solid #CC0000;
        }
        .piece.selected {
            border: 2px solid #007bff;
            box-shadow: 0 0 10px #007bff;
        }
        .highlight-move {
            background-color: rgba(0, 255, 0, 0.3);
            cursor: pointer;
        }
        .highlight-capture {
            background-color: rgba(255, 0, 0, 0.3);
            cursor: pointer;
        }
        .highlight-check {
            background-color: rgba(255, 165, 0, 0.5);
        }
        #message {
            margin-top: 20px;
            font-size: 1.2em;
            color: #333;
        }
        #turn-info {
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #0056b3;
        }
        #promotion-dialog {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .dialog-content {
            background-color: #fff;
            padding: 30px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            max-width: 300px;
        }
        .dialog-content p {
            margin-bottom: 20px;
            font-size: 1.5em;
            font-weight: bold;
            color: #333;
        }
        .dialog-buttons button {
            padding: 12px 25px;
            margin: 0 10px;
            border: none;
            border-radius: 5px;
            font-size: 1.2em;
            cursor: pointer;
            transition: background-color 0.3s ease;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.2);
        }
        #promote-button {
            background-color: #28a745;
            color: white;
        }
        #promote-button:hover {
            background-color: #218838;
        }
        #not-promote-button {
            background-color: #dc3545;
            color: white;
        }
        #not-promote-button:hover {
            background-color: #c82333;
        }
        #not-promote-button.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #cccccc;
            color: #666666;
        }
    </style>
</head>
<body>
    <h1>将棋</h1>
    <div id="turn-info">手番: <span id="current-turn">先手</span></div>
    <div id="game-area">
        <div id="player2-hand"></div>
        <div id="shogi-board"></div>
        <div id="player1-hand"></div>
    </div>
    <p id="message">先手の番です。駒をクリックして移動してください。</p>

    <div id="promotion-dialog">
        <div class="dialog-content">
            <p id="promotion-message">駒を成りますか? </p>
            <div class="dialog-buttons">
                <button id="promote-button">成る</button>
                <button id="not-promote-button">成らない</button>
            </div>
        </div>
    </div>

    <script>
        const boardElement = document.getElementById('shogi-board');
        const messageElement = document.getElementById('message');
        const turnInfoElement = document.getElementById('current-turn');
        const player1HandElement = document.getElementById('player1-hand');
        const player2HandElement = document.getElementById('player2-hand');
        const promotionDialog = document.getElementById('promotion-dialog');
        const promoteButton = document.getElementById('promote-button');
        const notPromoteButton = document.getElementById('not-promote-button');
        const promotionMessage = document.getElementById('promotion-message');

        const boardSize = 9;

        function getInitialBoardState() {
            return [
                [-2, -3, -4, -5, -8, -5, -4, -3, -2],
                [0, -7, 0, 0, 0, 0, 0, -6, 0],
                [-1, -1, -1, -1, -1, -1, -1, -1, -1],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 1, 1, 1, 1, 1, 1, 1, 1],
                [0, 6, 0, 0, 0, 0, 0, 7, 0],
                [2, 3, 4, 5, 8, 5, 4, 3, 2]
            ];
        }

        const pieceNames = {
            1: '歩', 2: '香', 3: '桂', 4: '銀', 5: '金', 6: '角', 7: '飛', 8: '王',
            9: 'と', 10: '成香', 11: '成桂', 12: '成銀', 13: '馬', 14: '龍',
            '-1': '歩', '-2': '香', '-3': '桂', '-4': '銀', '-5': '金', '-6': '角', '-7': '飛', '-8': '王',
            '-9': 'と', '-10': '成香', '-11': '成桂', '-12': '成銀', '-13': '馬', '-14': '龍'
        };

        let currentBoard = deepCloneBoard(getInitialBoardState());
        let player1Hand = [];
        let player2Hand = [];
        let selectedPiece = null;
        let selectedPiecePos = { row: -1, col: -1 };
        let currentTurn = 1;
        let gameOver = false;

        function deepCloneBoard(board) {
            return JSON.parse(JSON.stringify(board));
        }

        function simulateMove(board, fromRow, fromCol, toRow, toCol, pieceToDrop = null) {
            const newBoard = deepCloneBoard(board);
            
            if (fromRow === -1 && fromCol === -1) {
                newBoard[toRow][toCol] = pieceToDrop;
            } else {
                const pieceValue = newBoard[fromRow][fromCol];
                newBoard[toRow][toCol] = pieceValue;
                newBoard[fromRow][fromCol] = 0;
            }
            return newBoard;
        }

// 前半からの続き

        const pawnMoves = [[-1, 0]];
        const lanceMoves = [[-1, 0]];
        const knightMoves = [[-2, -1], [-2, 1]];
        const silverMoves = [[-1, 0], [-1, -1], [-1, 1], [1, -1], [1, 1]];
        const goldMoves = [[-1, 0], [1, 0], [0, 1], [0, -1], [-1, -1], [-1, 1]];
        const bishopMoves = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
        const rookMoves = [[-1, 0], [1, 0], [0, 1], [0, -1]];
        const kingMoves = [[-1, 0], [-1, -1], [-1, 1], [0, -1], [0, 1], [1, 0], [1, -1], [1, 1]];

        function getPieceMoves(pieceValue) {
            const absValue = Math.abs(pieceValue);
            switch (absValue) {
                case 1: return pawnMoves;
                case 9: return goldMoves;
                case 2: return lanceMoves;
                case 10: return goldMoves;
                case 3: return knightMoves;
                case 11: return goldMoves;
                case 4: return silverMoves;
                case 12: return goldMoves;
                case 5: return goldMoves;
                case 6: return bishopMoves;
                case 13: return [...bishopMoves, ...kingMoves];
                case 7: return rookMoves;
                case 14: return [...rookMoves, ...kingMoves];
                case 8: return kingMoves;
                default: return [];
            }
        }

        function isLongRangePiece(pieceValue) {
            const absValue = Math.abs(pieceValue);
            return absValue === 2 || absValue === 6 || absValue === 7 || absValue === 13 || absValue === 14;
        }

        function drawBoard() {
            boardElement.innerHTML = '';
            for (let r = 0; r < boardSize; r++) {
                for (let c = 0; c < boardSize; c++) {
                    const square = document.createElement('div');
                    square.classList.add('square');
                    square.dataset.row = r;
                    square.dataset.col = c;

                    const pieceValue = currentBoard[r][c];
                    if (pieceValue !== 0) {
                        const piece = document.createElement('div');
                        piece.classList.add('piece');
                        piece.textContent = pieceNames[Math.abs(pieceValue)];
                        piece.dataset.value = pieceValue;
                        piece.dataset.absValue = Math.abs(pieceValue);
                        piece.classList.add(pieceValue > 0 ? 'player1' : 'player2');
                        if (Math.abs(pieceValue) > 8) {
                            piece.classList.add('promoted');
                        }
                        square.appendChild(piece);
                    }
                    boardElement.appendChild(square);
                }
            }
            updateCheckHighlight();
        }

        function drawHands() {
            player1HandElement.innerHTML = '';
            player2HandElement.innerHTML = '';

            player1Hand.forEach(pieceValue => {
                const piece = document.createElement('div');
                piece.classList.add('hand-piece');
                piece.classList.add('player1');
                piece.textContent = pieceNames[Math.abs(pieceValue)];
                piece.dataset.value = pieceValue;
                piece.dataset.isHand = 'true';
                player1HandElement.appendChild(piece);
            });

            player2Hand.forEach(pieceValue => {
                const piece = document.createElement('div');
                piece.classList.add('hand-piece');
                piece.classList.add('player2');
                piece.textContent = pieceNames[Math.abs(pieceValue)];
                piece.dataset.value = pieceValue;
                piece.dataset.isHand = 'true';
                player2HandElement.appendChild(piece);
            });
        }

        function clearHighlights() {
            document.querySelectorAll('.highlight-move, .highlight-capture').forEach(sq => {
                sq.classList.remove('highlight-move', 'highlight-capture');
            });
        }

        function getSquareElement(row, col) {
            return boardElement.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        }

        function highlightValidMoves(row, col, pieceValue) {
            clearHighlights();

            const moves = getPieceMoves(pieceValue);
            const isLongRange = isLongRangePiece(pieceValue);
            const player = Math.sign(pieceValue);
            const absValue = Math.abs(pieceValue);

            const validMoves = [];
            const oneSquareMoves = [];
            let longRangeMoves = [];

            if (absValue === 13) {
                oneSquareMoves.push(...kingMoves);
                longRangeMoves.push(...bishopMoves);
            } else if (absValue === 14) {
                oneSquareMoves.push(...kingMoves);
                longRangeMoves.push(...rookMoves);
            } else {
                if (isLongRange) {
                    longRangeMoves.push(...moves);
                } else {
                    oneSquareMoves.push(...moves);
                }
            }

            for (const [dy, dx] of oneSquareMoves) {
                const newRow = row + dy * player;
                const newCol = col + dx;

                if (newRow >= 0 && newRow < boardSize && newCol >= 0 && newCol < boardSize) {
                    const targetPieceValue = currentBoard[newRow][newCol];
                    const targetPlayer = Math.sign(targetPieceValue);

                    if (targetPlayer === player) {
                        continue;
                    }

                    const simulatedBoard = simulateMove(currentBoard, row, col, newRow, newCol);
                    if (!isKingInCheck(player, simulatedBoard)) {
                        validMoves.push({ row: newRow, col: newCol, isCapture: (targetPieceValue !== 0) });
                    }
                }
            }

            for (const [dy, dx] of longRangeMoves) {
                let newRow = row + dy * player;
                let newCol = col + dx;

                while (newRow >= 0 && newRow < boardSize && newCol >= 0 && newCol < boardSize) {
                    const targetPieceValue = currentBoard[newRow][newCol];
                    const targetPlayer = Math.sign(targetPieceValue);

                    if (targetPlayer === player) {
                        break;
                    }

                    const simulatedBoard = simulateMove(currentBoard, row, col, newRow, newCol);
                    if (!isKingInCheck(player, simulatedBoard)) {
                        validMoves.push({ row: newRow, col: newCol, isCapture: (targetPieceValue !== 0) });
                    }

                    if (targetPieceValue !== 0 && targetPlayer !== player) {
                        break;
                    }

                    newRow += dy * player;
                    newCol += dx;
                }
            }

            validMoves.forEach(move => {
                const squareElement = getSquareElement(move.row, move.col);
                if (squareElement) {
                    squareElement.classList.add(move.isCapture ? 'highlight-capture' : 'highlight-move');
                }
            });
        }

        function highlightDropMoves(pieceValue) {
            clearHighlights();

            const player = Math.sign(pieceValue);
            const absValue = Math.abs(pieceValue);

            for (let r = 0; r < boardSize; r++) {
                for (let c = 0; c < boardSize; c++) {
                    if (currentBoard[r][c] === 0) {
                        let isValidDrop = true;

                        if (absValue === 1 || absValue === 2) {
                            if ((player === 1 && r === 0) || (player === -1 && r === boardSize - 1)) {
                                isValidDrop = false;
                            }
                        } else if (absValue === 3) {
                            if ((player === 1 && r <= 1) || (player === -1 && r >= boardSize - 2)) {
                                isValidDrop = false;
                            }
                        }

                        if (isValidDrop && absValue === 1) {
                            for (let i = 0; i < boardSize; i++) {
                                if (Math.abs(currentBoard[i][c]) === 1 && Math.sign(currentBoard[i][c]) === player) {
                                    isValidDrop = false;
                                    break;
                                }
                            }
                        }

                        if (isValidDrop && absValue === 1 && !isKingInCheck(player, currentBoard)) {
                            const tempBoardForCheckmate = simulateMove(currentBoard, -1, -1, r, c, absValue * player);
                            const isCheckmateAfterDrop = isCheckmate(-player, tempBoardForCheckmate);
                            if (isCheckmateAfterDrop) {
                                isValidDrop = false;
                            }
                        }

                        const simulatedDropBoard = simulateMove(currentBoard, -1, -1, r, c, pieceValue);
                        if (isValidDrop && isKingInCheck(player, simulatedDropBoard)) {
                            isValidDrop = false;
                        }

                        if (isValidDrop) {
                            const squareElement = getSquareElement(r, c);
                            if (squareElement) {
                                squareElement.classList.add('highlight-move');
                            }
                        }
                    }
                }
            }
        }

        function isKingInCheck(player, board) {
            const kingPos = findKingPosition(player, board);
            if (!kingPos) {
                return false;
            }

            const opponentPlayer = -player;
            for (let r = 0; r < boardSize; r++) {
                for (let c = 0; c < boardSize; c++) {
                    const pieceValue = board[r][c];
                    if (Math.sign(pieceValue) === opponentPlayer) {
                        if (canPieceMoveTo(r, c, pieceValue, kingPos.row, kingPos.col, board)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function canPieceMoveTo(startRow, startCol, pieceValue, endRow, endCol, board) {
            const player = Math.sign(pieceValue);
            const absValue = Math.abs(pieceValue);
            const moves = getPieceMoves(pieceValue);

            const isLongRange = isLongRangePiece(pieceValue);

            let oneSquareMoves = [];
            let longRangeMoves = [];

            if (absValue === 13) {
                oneSquareMoves = kingMoves;
                longRangeMoves = bishopMoves;
            } else if (absValue === 14) {
                oneSquareMoves = kingMoves;
                longRangeMoves = rookMoves;
            } else if (isLongRange) {
                longRangeMoves = moves;
            } else {
                oneSquareMoves = moves;
            }

            for (const [dy, dx] of oneSquareMoves) {
                const actualDy = dy * player;
                const actualDx = dx;

                const newRow = startRow + actualDy;
                const newCol = startCol + actualDx;

                if (newRow >= 0 && newRow < boardSize && newCol >= 0 && newCol < boardSize) {
                    if (newRow === endRow && newCol === endCol) {
                        const targetPiece = board[endRow][endCol];
                        if (Math.sign(targetPiece) === player && targetPiece !== 0) {
                            return false;
                        }
                        return true;
                    }
                }
            }

            for (const [dy, dx] of longRangeMoves) {
                let newRow = startRow + dy * player;
                let newCol = startCol + dx;

                while (newRow >= 0 && newRow < boardSize && newCol >= 0 && newCol < boardSize) {
                    const targetPieceValue = board[newRow][newCol];

                    if (newRow === endRow && newCol === endCol) {
                        const targetPlayer = Math.sign(targetPieceValue);
                        if (targetPlayer === player && targetPieceValue !== 0) {
                            return false;
                        }
                        return true;
                    }

                    if (targetPieceValue !== 0) {
                        break;
                    }

                    newRow += dy * player;
                    newCol += dx;
                }
            }
            return false;
        }

        function findKingPosition(player, board) {
            for (let r = 0; r < boardSize; r++) {
                for (let c = 0; c < boardSize; c++) {
                    const pieceValue = board[r][c];
                    if (Math.abs(pieceValue) === 8 && Math.sign(pieceValue) === player) {
                        return { row: r, col: c };
                    }
                }
            }
            return null;
        }

        function updateCheckHighlight() {
            document.querySelectorAll('.highlight-check').forEach(sq => {
                sq.classList.remove('highlight-check');
            });

            if (isKingInCheck(currentTurn, currentBoard)) {
                const kingPos = findKingPosition(currentTurn, currentBoard);
                if (kingPos) {
                    getSquareElement(kingPos.row, kingPos.col).classList.add('highlight-check');
                    messageElement.textContent = `${currentTurn === 1 ? '先手' : '後手'}は王手されています！`;
                }
            } else {
                messageElement.textContent = `${currentTurn === 1 ? '先手' : '後手'}の番です。駒をクリックして移動してください。`;
            }
        }

        function isCheckmate(player, board) {
            if (!isKingInCheck(player, board)) {
                return false;
            }

            for (let r = 0; r < boardSize; r++) {
                for (let c = 0; c < boardSize; c++) {
                    const pieceValue = board[r][c];
                    if (Math.sign(pieceValue) === player) {
                        const absValue = Math.abs(pieceValue);
                        const moves = getPieceMoves(pieceValue);

                        const isLongRange = isLongRangePiece(pieceValue);

                        let oneSquareMoves = [];
                        let longRangeMoves = [];

                        if (absValue === 13) {
                            oneSquareMoves.push(...kingMoves);
                            longRangeMoves.push(...bishopMoves);
                        } else if (absValue === 14) {
                            oneSquareMoves.push(...kingMoves);
                            longRangeMoves.push(...rookMoves);
                        } else if (isLongRange) {
                            longRangeMoves.push(...moves);
                        } else {
                            oneSquareMoves.push(...moves);
                        }

                        for (const [dy, dx] of oneSquareMoves) {
                            const newRow = r + dy * player;
                            const newCol = c + dx;

                            if (newRow >= 0 && newRow < boardSize && newCol >= 0 && newCol < boardSize) {
                                const targetPieceValue = board[newRow][newCol];
                                const targetPlayer = Math.sign(targetPieceValue);

                                if (targetPlayer === player && targetPieceValue !== 0) {
                                    continue;
                                }

                                let isMoveValidByRule = true;
                                if (absValue === 1 || absValue === 2) {
                                    if ((player === 1 && newRow === 0) || (player === -1 && newRow === boardSize - 1)) {
                                        isMoveValidByRule = false;
                                    }
                                } else if (absValue === 3) {
                                    if ((player === 1 && newRow <= 1) || (player === -1 && newRow >= boardSize - 2)) {
                                        isMoveValidByRule = false;
                                    }
                                }

                                if (!isMoveValidByRule) {
                                    continue;
                                }

                                const simulatedBoard = simulateMove(board, r, c, newRow, newCol);
                                if (!isKingInCheck(player, simulatedBoard)) {
                                    return false;
                                }
                            }
                        }

                        for (const [dy, dx] of longRangeMoves) {
                            let newRow = r + dy * player;
                            let newCol = c + dx;

                            while (newRow >= 0 && newRow < boardSize && newCol >= 0 && newCol < boardSize) {
                                const targetPieceValue = board[newRow][newCol];
                                const targetPlayer = Math.sign(targetPieceValue);

                                if (targetPlayer === player && targetPieceValue !== 0) {
                                    break;
                                }

                                let isMoveValidByRule = true;
                                if (absValue === 2) {
                                    if ((player === 1 && newRow === 0) || (player === -1 && newRow === boardSize - 1)) {
                                        isMoveValidByRule = false;
                                    }
                                }

                                if (!isMoveValidByRule) {
                                    if (newRow === r + dy * player && newCol === c + dx) {
                                        break;
                                    } else {
                                        const simulatedBoard = simulateMove(board, r, c, newRow, newCol);
                                        if (!isKingInCheck(player, simulatedBoard)) {
                                            return false;
                                        }
                                    }
                                } else {
                                    const simulatedBoard = simulateMove(board, r, c, newRow, newCol);
                                    if (!isKingInCheck(player, simulatedBoard)) {
                                        return false;
                                    }
                                }

                                if (targetPieceValue !== 0 && targetPlayer !== player) {
                                    break;
                                }

                                newRow += dy * player;
                                newCol += dx;
                            }
                        }
                    }
                }
            }

            const handPieces = (player === 1) ? player1Hand : player2Hand;

            for (const handPieceValue of handPieces) {
                const absHandPieceValue = Math.abs(handPieceValue);
                for (let r = 0; r < boardSize; r++) {
                    for (let c = 0; c < boardSize; c++) {
                        if (board[r][c] === 0) {
                            let isValidDropMove = true;

                            if ((absHandPieceValue === 1 || absHandPieceValue === 2) && ((player === 1 && r === 0) || (player === -1 && r === boardSize - 1))) {
                                isValidDropMove = false;
                            } else if (absHandPieceValue === 3 && ((player === 1 && r <= 1) || (player === -1 && r >= boardSize - 2))) {
                                isValidDropMove = false;
                            }

                            if (!isValidDropMove) {
                                continue;
                            }

                            if (absHandPieceValue === 1) {
                                for (let i = 0; i < boardSize; i++) {
                                    if (Math.abs(board[i][c]) === 1 && Math.sign(board[i][c]) === player) {
                                        isValidDropMove = false;
                                        break;
                                    }
                                }
                            }
                            if (!isValidDropMove) {
                                continue;
                            }

                            if (absHandPieceValue === 1) {
                                const tempBoardForUchifuzume = simulateMove(board, -1, -1, r, c, absHandPieceValue * player);
                                if (isCheckmate(-player, tempBoardForUchifuzume)) {
                                    continue;
                                }
                            }

                            const nextTempBoard = simulateMove(board, -1, -1, r, c, handPieceValue);
                            if (!isKingInCheck(player, nextTempBoard)) {
                                return false;
                            }
                        }
                    }
                }
            }

            return true;
        }

        function capturePiece(pieceValue, player) {
            let pieceToAdd = Math.abs(pieceValue);

            if (pieceToAdd === 9) pieceToAdd = 1;
            else if (pieceToAdd === 10) pieceToAdd = 2;
            else if (pieceToAdd === 11) pieceToAdd = 3;
            else if (pieceToAdd === 12) pieceToAdd = 4;
            else if (pieceToAdd === 13) pieceToAdd = 6;
            else if (pieceToAdd === 14) pieceToAdd = 7;

            if (player === 1) {
                player1Hand.push(pieceToAdd);
            } else {
                player2Hand.push(-pieceToAdd);
            }

            player1Hand.sort((a, b) => Math.abs(a) - Math.abs(b));
            player2Hand.sort((a, b) => Math.abs(a) - Math.abs(b));
        }

        function removePieceFromHand(pieceValue, player) {
            if (player === 1) {
                const index = player1Hand.indexOf(pieceValue);
                if (index > -1) {
                    player1Hand.splice(index, 1);
                }
            } else {
                const index = player2Hand.indexOf(pieceValue);
                if (index > -1) {
                    player2Hand.splice(index, 1);
                }
            }
        }

        function canPromote(pieceValue, fromRow, toRow, player) {
            const absValue = Math.abs(pieceValue);

            if (absValue === 8 || absValue === 5) {
                return false;
            }

            if (absValue > 8) {
                return false;
            }

            const isFromPromotionZone = (player === 1 && fromRow <= 2) ||
                (player === -1 && fromRow >= boardSize - 3);
            const isToPromotionZone = (player === 1 && toRow <= 2) ||
                (player === -1 && toRow >= boardSize - 3);

            return isFromPromotionZone || isToPromotionZone;
        }

        function isForcedPromotionSquare(pieceValue, toRow, player) {
            const absValue = Math.abs(pieceValue);

            if (absValue === 8 || absValue === 5) {
                return false;
            }

            if (absValue > 8) {
                return false;
            }

            if ((absValue === 1 || absValue === 2) && ((player === 1 && toRow === 0) || (player === -1 && toRow === boardSize - 1))) {
                return true;
            }
            if (absValue === 3 && ((player === 1 && toRow <= 1) || (player === -1 && toRow >= boardSize - 2))) {
                return true;
            }
            return false;
        }

        function getPromotedPiece(pieceValue) {
            const playerSign = Math.sign(pieceValue);
            const absValue = Math.abs(pieceValue);

            if (absValue >= 1 && absValue <= 4) {
                return (absValue + 8) * playerSign;
            } else if (absValue === 6) {
                return (absValue + 7) * playerSign;
            } else if (absValue === 7) {
                return (absValue + 7) * playerSign;
            }
            return pieceValue;
        }

        function showPromotionDialog(pieceName, isForced = false) {
            return new Promise(resolve => {
                promotionMessage.textContent = `${pieceName}を成りますか？`;
                promotionDialog.style.display = 'flex';

                if (isForced) {
                    notPromoteButton.classList.add('disabled');
                    notPromoteButton.disabled = true;
                } else {
                    notPromoteButton.classList.remove('disabled');
                    notPromoteButton.disabled = false;
                }

                const handlePromote = () => {
                    promotionDialog.style.display = 'none';
                    promoteButton.removeEventListener('click', handlePromote);
                    notPromoteButton.removeEventListener('click', handleNotPromote);
                    promotionDialog.removeEventListener('click', handleOutsideClick);
                    resolve(true);
                };

                const handleNotPromote = () => {
                    promotionDialog.style.display = 'none';
                    promoteButton.removeEventListener('click', handlePromote);
                    notPromoteButton.removeEventListener('click', handleNotPromote);
                    promotionDialog.removeEventListener('click', handleOutsideClick);
                    resolve(false);
                };

                const handleOutsideClick = (event) => {
                    if (!event.target.closest('.dialog-content')) {
                        if (isForced) {
                            handlePromote();
                        } else {
                            promotionDialog.style.display = 'none';
                            promoteButton.removeEventListener('click', handlePromote);
                            notPromoteButton.removeEventListener('click', handleNotPromote);
                            promotionDialog.removeEventListener('click', handleOutsideClick);
                            resolve(false);
                            if (selectedPiece) {
                                selectedPiece.classList.remove('selected');
                                selectedPiece = null;
                                selectedPiecePos = { row: -1, col: -1 };
                                clearHighlights();
                                messageElement.textContent = '駒の選択を解除しました。自分の駒をクリックして移動してください。';
                                updateTurnInfo();
                            }
                        }
                    }
                };

                promoteButton.addEventListener('click', handlePromote);
                notPromoteButton.addEventListener('click', handleNotPromote);
                promotionDialog.addEventListener('click', handleOutsideClick);
            });
        }

        boardElement.addEventListener('click', async (event) => {
            if (gameOver) return;

            const clickedSquare = event.target.closest('.square');
            const clickedPiece = event.target.closest('.piece');

            if (!selectedPiece) {
                if (clickedPiece) {
                    const pieceValue = parseInt(clickedPiece.dataset.value);
                    if (Math.sign(pieceValue) === currentTurn) {
                        selectedPiece = clickedPiece;
                        selectedPiece.classList.add('selected');
                        selectedPiecePos = { row: parseInt(clickedSquare.dataset.row), col: parseInt(clickedSquare.dataset.col) };
                        highlightValidMoves(selectedPiecePos.row, selectedPiecePos.col, pieceValue);
                        messageElement.textContent = `${pieceNames[Math.abs(pieceValue)]}を選択しました。移動先を選んでください。`;
                    } else {
                        messageElement.textContent = '相手の駒です。自分の駒を選択してください。';
                    }
                }
            } else {
                const selectedPieceValue = parseInt(selectedPiece.dataset.value);
                const isSelectedPieceFromHand = selectedPiece.dataset.isHand === 'true';

                if (clickedSquare) {
                    const targetRow = parseInt(clickedSquare.dataset.row);
                    const targetCol = parseInt(clickedSquare.dataset.col);
                    const targetPieceValueOnBoard = currentBoard[targetRow][targetCol];
                    const targetPlayer = Math.sign(targetPieceValueOnBoard);

                    if (isSelectedPieceFromHand) {
                        if (!clickedSquare.classList.contains('highlight-move')) {
                            messageElement.textContent = 'そこには打てません。ハイライトされたマスを選んでください。';
                            selectedPiece.classList.remove('selected');
                            selectedPiece = null;
                            selectedPiecePos = { row: -1, col: -1 };
                            clearHighlights();
                            updateTurnInfo();
                            return;
                        }

                        removePieceFromHand(selectedPieceValue, currentTurn);
                        currentBoard[targetRow][targetCol] = selectedPieceValue;

                        if (isForcedPromotionSquare(selectedPieceValue, targetRow, currentTurn)) {
                            currentBoard[targetRow][targetCol] = getPromotedPiece(currentBoard[targetRow][targetCol]);
                        }

                        drawBoard();
                        drawHands();
                        selectedPiece.classList.remove('selected');
                        selectedPiece = null;
                        selectedPiecePos = { row: -1, col: -1 };
                        clearHighlights();
                        switchTurn();
                        return;
                    }

                    const fromRow = selectedPiecePos.row;
                    const fromCol = selectedPiecePos.col;
                    const absSelectedPieceValue = Math.abs(selectedPieceValue);

                    if (clickedPiece && targetPlayer === currentTurn && !isSelectedPieceFromHand) {
                        selectedPiece.classList.remove('selected');
                        selectedPiece = clickedPiece;
                        selectedPiece.classList.add('selected');
                        selectedPiecePos = { row: targetRow, col: targetCol };
                        highlightValidMoves(targetRow, targetCol, targetPieceValueOnBoard);
                        messageElement.textContent = `${pieceNames[Math.abs(targetPieceValueOnBoard)]}を選択しました。移動先を選んでください。`;
                        return;
                    }

                    if (!clickedSquare.classList.contains('highlight-move') && !clickedSquare.classList.contains('highlight-capture')) {
                        messageElement.textContent = 'そこには移動できません。ハイライトされたマスを選んでください。';
                        selectedPiece.classList.remove('selected');
                        selectedPiece = null;
                        selectedPiecePos = { row: -1, col: -1 };
                        clearHighlights();
                        updateTurnInfo();
                        return;
                    }

                    if (targetPieceValueOnBoard !== 0 && targetPlayer === -currentTurn) {
                        capturePiece(targetPieceValueOnBoard, currentTurn);
                    }

                    let shouldPromote = false;
                    const canPieceBePromoted = canPromote(selectedPieceValue, fromRow, targetRow, currentTurn);
                    const forcedPromotion = isForcedPromotionSquare(selectedPieceValue, targetRow, currentTurn);

                    if (canPieceBePromoted) {
                        shouldPromote = await showPromotionDialog(pieceNames[absSelectedPieceValue], forcedPromotion);

                        if (selectedPiece === null) {
                            return;
                        }
                    }

                    currentBoard = simulateMove(currentBoard, fromRow, fromCol, targetRow, targetCol);

                    if (shouldPromote) {
                        currentBoard[targetRow][targetCol] = getPromotedPiece(currentBoard[targetRow][targetCol]);
                    }

                    drawBoard();
                    drawHands();

                    if (selectedPiece) {
                        selectedPiece.classList.remove('selected');
                    }
                    selectedPiece = null;
                    selectedPiecePos = { row: -1, col: -1 };
                    clearHighlights();
                    switchTurn();
                }
            }
        });

        player1HandElement.addEventListener('click', handleHandClick);
        player2HandElement.addEventListener('click', handleHandClick);

        async function handleHandClick(event) {
            if (gameOver) return;

            const clickedPiece = event.target.closest('.hand-piece');
            if (!clickedPiece) return;

            const pieceValue = parseInt(clickedPiece.dataset.value);

            if (selectedPiece) {
                selectedPiece.classList.remove('selected');
                selectedPiece = null;
                selectedPiecePos = { row: -1, col: -1 };
                clearHighlights();

                if (clickedPiece === event.target.closest('.hand-piece')) {
                    messageElement.textContent = '駒の選択を解除しました。自分の駒をクリックして移動してください。';
                    updateTurnInfo();
                    return;
                }
            }

            if (Math.sign(pieceValue) === currentTurn) {
                selectedPiece = clickedPiece;
                selectedPiece.classList.add('selected');
                selectedPiecePos = { row: -1, col: -1 };

                messageElement.textContent = `${pieceNames[Math.abs(pieceValue)]}を打ちます。どこへ打ちますか？`;
                highlightDropMoves(pieceValue);
            } else {
                messageElement.textContent = '相手の駒です。自分の駒を選択してください。';
            }
        }

        function switchTurn() {
            currentTurn *= -1;
            updateTurnInfo();
            clearHighlights();

            if (isCheckmate(currentTurn, currentBoard)) {
                gameOver = true;
                messageElement.textContent = `${currentTurn === 1 ? '先手' : '後手'}が詰みました！ゲーム終了！`;
            } else {
                updateCheckHighlight();
            }
        }

        function updateTurnInfo() {
            turnInfoElement.textContent = currentTurn === 1 ? '先手' : '後手';
            if (!gameOver) {
                messageElement.textContent = `${currentTurn === 1 ? '先手' : '後手'}の番です。駒をクリックして移動してください。`;
            }
        }

        window.onload = () => {
            drawBoard();
            drawHands();
            updateTurnInfo();
        };
    </script>
</body>
</html>

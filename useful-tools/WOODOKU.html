<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WOODOKU - ãƒ–ãƒ­ãƒƒã‚¯å›è»¢æ©Ÿèƒ½ä»˜ã</title>
    <style>
        /* CSSã‚¹ã‚¿ã‚¤ãƒ« */
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #e8e0d4; /* è½ã¡ç€ã„ãŸèƒŒæ™¯ */
            padding: 20px;
            margin: 0;
            color: #3e2723; /* æ¿ƒã„èŒ¶è‰²ã®ãƒ†ã‚­ã‚¹ãƒˆ */
            user-select: none; /* ã‚¿ãƒƒãƒãƒ‡ãƒã‚¤ã‚¹ã§ã®é¸æŠé˜²æ­¢ */
        }
        
        h1 {
            color: #6b4c3e;
            margin-bottom: 20px;
            font-size: 2.5rem;
            font-weight: 800;
        }

        #game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 400px;
            margin-bottom: 10px;
            font-size: 1.1rem;
            font-weight: 600;
        }

        #game-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        #board {
            display: grid;
            /* ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œã®ãŸã‚ã€vwã¨å›ºå®šå€¤ã§æœ€å¤§å¹…ã‚’åˆ¶å¾¡ */
            grid-template-columns: repeat(9, min(4.5vw, 40px));
            grid-template-rows: repeat(9, min(4.5vw, 40px));
            gap: 1px;
            border: 4px solid #6b4c3e;
            background-color: #6b4c3e;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
            border-radius: 8px;
        }

        .cell {
            background-color: #f5e4c6; /* ãƒœãƒ¼ãƒ‰ã®ç©ºããƒã‚¹ */
            box-sizing: border-box;
            transition: background-color 0.1s;
        }

        .cell.filled {
            background-color: #a07a5c; /* é…ç½®ã•ã‚ŒãŸãƒ–ãƒ­ãƒƒã‚¯ã®ãƒã‚¹ */
            border: 1px solid #795548;
            border-radius: 2px;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
        }

        /* 3x3ãƒ–ãƒ­ãƒƒã‚¯ã®å¢ƒç•Œ (è¦‹ãŸç›®ã¨ã—ã¦æ®‹ã™) */
        .cell:nth-child(9n+4), .cell:nth-child(9n+7) {
            border-left: 2px solid #6b4c3e;
        }
        .cell:nth-child(n+19):nth-child(-n+27),
        .cell:nth-child(n+46):nth-child(-n+54) {
            border-bottom: 2px solid #6b4c3e;
        }
        
        /* ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚»ãƒ«ã«é…ç½®å¯èƒ½ã‹ã©ã†ã‹ã®è¦–è¦šçš„ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ï¼ˆãƒ–ãƒ­ãƒƒã‚¯å…¨ä½“ï¼‰ */
        .cell.potential-placement {
            /* ãƒ–ãƒ­ãƒƒã‚¯ã®å½¢å…¨ä½“ãŒãƒã‚¤ãƒ©ã‚¤ãƒˆã•ã‚Œã‚‹ */
            background-color: #c9b499; /* é…ç½®å¯èƒ½ãªãƒã‚¹ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
            box-shadow: 0 0 5px #3e2723;
        }

        /* ç¾åœ¨ã®ãƒ–ãƒ­ãƒƒã‚¯è¡¨ç¤ºã‚¨ãƒªã‚¢ */
        #current-blocks {
            display: flex;
            gap: 20px;
            padding: 15px;
            background-color: #fff8e1;
            border: 2px solid #6b4c3e;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            margin-bottom: 20px;
        }

        .block-preview {
            background-color: #d7c3a0;
            padding: 8px;
            cursor: grab;
            user-select: none;
            display: inline-block;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: transform 0.1s, opacity 0.1s;
            touch-action: none; 
        }

        .block-preview:hover {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transform: translateY(-2px);
        }
        
        .block-preview.dragging {
            opacity: 0.4; 
            pointer-events: none; 
        }

        .block-row {
            display: flex;
        }

        .block-cell {
            width: 25px;
            height: 25px;
            background-color: transparent;
            margin: 1px;
            box-sizing: border-box;
        }

        .block-cell.active {
            background-color: #a07a5c;
            border: 1px solid #795548;
            border-radius: 2px;
        }

        /* ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ã‚´ãƒ¼ã‚¹ãƒˆè¦ç´  */
        .ghost-block {
            position: fixed;
            pointer-events: none; 
            z-index: 1000;
            opacity: 0.9;
            background-color: transparent !important;
            box-shadow: none !important;
        }
        .ghost-block .block-cell.active {
            background-color: #795548; 
            border-color: #5d4037;
        }


        #controls {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        button {
            padding: 10px 20px;
            background-color: #6b4c3e;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 700;
            box-shadow: 0 4px #4e342e;
            transition: background-color 0.1s, transform 0.1s, box-shadow 0.1s;
        }

        button:active {
            box-shadow: 0 2px #4e342e;
            transform: translateY(2px);
        }

        #message {
            margin-top: 15px;
            font-size: 1.2rem;
            font-weight: bold;
            color: #3e2723;
        }

        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
        @media (max-width: 600px) {
            #board {
                grid-template-columns: repeat(9, 8vw);
                grid-template-rows: repeat(9, 8vw);
                gap: 0.5px;
                max-width: 90vw;
            }

            .block-cell {
                width: 18px;
                height: 18px;
            }

            #current-blocks {
                gap: 10px;
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <h1>WOODOKU ãƒ‘ã‚ºãƒ«</h1>
    
    <div id="game-info">
        <span>ã‚¹ã‚³ã‚¢: <span id="score">0</span></span>
        <button onclick="initGame()">ãƒªã‚»ãƒƒãƒˆ/é–‹å§‹</button>
    </div>

    <div id="game-container">
        <div id="board">
            <!-- ãƒœãƒ¼ãƒ‰ã®ãƒã‚¹ã¯JSã§ç”Ÿæˆã•ã‚Œã¾ã™ -->
        </div>
    </div>
    
    <h2>æ¬¡ã«é…ç½®ã™ã‚‹ãƒ–ãƒ­ãƒƒã‚¯</h2>
    <div id="current-blocks">
        <!-- 3ã¤ã®ãƒ–ãƒ­ãƒƒã‚¯ã¯JSã§ç”Ÿæˆã•ã‚Œã¾ã™ -->
    </div>
    
    <p id="message"></p>

    <script>
        // --- 1. ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ã¨å®šæ•° ---
        const BOARD_SIZE = 9;
        let board = [];
        let currentBlocks = [];
        let score = 0;
        let isGameOver = false;

        // ãƒ‰ãƒ©ãƒƒã‚°/ã‚¿ãƒƒãƒç”¨ã®çŠ¶æ…‹
        let selectedBlockIndex = -1;
        let draggedBlockGhost = null; 
        let currentTargetCell = null;

        // ãƒ–ãƒ­ãƒƒã‚¯ã®åŸºæœ¬å½¢çŠ¶ï¼ˆå›è»¢å‰ã®å®šç¾©ï¼‰
        const BASE_BLOCK_SHAPES = [
            [[1]], // 1x1
            [[1, 1]], // 1x2 (æ¨ª)
            [[1, 1, 1]], // 1x3 (æ¨ª)
            [[1, 1, 1, 1]], // 1x4 (æ¨ª)
            [[1, 1, 1, 1, 1]], // 1x5 (æ¨ª)
            [[1, 1], [1, 1]], // 2x2 (æ­£æ–¹å½¢)
            [[1, 0], [1, 1]], // Lå­— (åŸºæœ¬)
            [[1, 1, 1], [0, 1, 0]], // Tå­—
            [[1, 1, 0], [0, 1, 1]], // Zå­—
            [[1, 1, 1], [1, 0, 0], [1, 0, 0]], // 3x3 Lå­—
            [[1, 0], [1, 0], [1, 1]], // ãƒŸãƒ‹Lå­—
            [[1, 1, 1], [1, 1, 1], [1, 1, 1]] // 3x3 (æ­£æ–¹å½¢)
        ];
const WEIGHTED_BLOCK_INDICES = [];
BASE_BLOCK_SHAPES.forEach((shape, index) => {
    // ãƒ–ãƒ­ãƒƒã‚¯ã®ãƒã‚¹ç›®ã®æ•°ï¼ˆé¢ç©ï¼‰ã‚’è¨ˆç®—
    const area = shape.flat().reduce((sum, val) => sum + val, 0);

    // é¢ç©ãŒ4ä»¥ä¸Šãªã‚‰é‡ã¿2ã€ãã†ã§ãªã‘ã‚Œã°é‡ã¿1
    const weight = area >= 4 ? 2 : 1;

    // é‡ã¿ã®æ•°ã ã‘ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’é…åˆ—ã«è¿½åŠ  (ç¢ºç‡ã‚’é‡ã¿ä»˜ã‘)
    for (let i = 0; i < weight; i++) {
        WEIGHTED_BLOCK_INDICES.push(index);
    }
});

        // --- 2. ãƒ–ãƒ­ãƒƒã‚¯å›è»¢é–¢æ•° ---

        /**
         * ãƒ–ãƒ­ãƒƒã‚¯ã®å½¢çŠ¶ (2Dé…åˆ—) ã‚’æ™‚è¨ˆå›ã‚Šã«90åº¦å›è»¢ã•ã›ã‚‹
         * @param {number[][]} shape 
         * @returns {number[][]}
         */
        function rotateShape(shape) {
            const rows = shape.length;
            const cols = shape[0].length;
            
            // æ–°ã—ã„å½¢çŠ¶ã®ã‚µã‚¤ã‚ºã¯å…ƒã®è¡Œã¨åˆ—ãŒå…¥ã‚Œæ›¿ã‚ã‚‹
            const newRows = cols;
            const newCols = rows;
            
            // æ–°ã—ã„é…åˆ—ã‚’åˆæœŸåŒ–
            const newShape = Array.from({ length: newRows }, () => Array(newCols).fill(0));

            // å›è»¢å‡¦ç† ( (r, c) -> (c, rows - 1 - r) )
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    newShape[c][rows - 1 - r] = shape[r][c];
                }
            }
            return newShape;
        }

        // --- 3. åˆæœŸåŒ–é–¢æ•° ---

        function initGame() {
            board = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(0));
            score = 0;
            isGameOver = false;
            document.getElementById('score').textContent = score;
            document.getElementById('message').textContent = 'ç¸¦ãƒ»æ¨ªã®ä¸€åˆ—ã‚¯ãƒªã‚¢ã‚’ç›®æŒ‡ã—ã¾ã—ã‚‡ã†ï¼';
            drawBoard();
            generateNewBlocks(); 
            document.getElementById('message').style.color = '#3e2723';
        }

        // --- 4. ãƒœãƒ¼ãƒ‰ã®æç”»ã¨ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š ---

        function drawBoard() {
            const boardEl = document.getElementById('board');
            const cells = boardEl.querySelectorAll('.cell');
            
            if (cells.length === 0) {
                // åˆå›æç”»æ™‚
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.dataset.row = r;
                        cell.dataset.col = c;

                        // ãƒã‚¦ã‚¹ãƒ‰ãƒ­ãƒƒãƒ—ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
                        cell.addEventListener('dragover', allowDrop);
                        cell.addEventListener('drop', handleDrop);

                        boardEl.appendChild(cell);
                    }
                }
            }
            
            // çŠ¶æ…‹ã®æ›´æ–°
            let cellIndex = 0;
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cell = cells[cellIndex] || boardEl.children[cellIndex];
                    if (board[r][c] === 1) {
                        cell.classList.add('filled');
                    } else {
                        cell.classList.remove('filled');
                    }
                    cellIndex++;
                }
            }
        }

        // --- 5. ãƒ–ãƒ­ãƒƒã‚¯ç”Ÿæˆã¨æç”» ---

function getRandomBlockShape() {
    
    // âœ… å¤‰æ›´å¾Œ: é‡ã¿ä»˜ã‘ã•ã‚ŒãŸé…åˆ—ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’é¸æŠ
    const randomIndex = Math.floor(Math.random() * WEIGHTED_BLOCK_INDICES.length);
    const baseShapeIndex = WEIGHTED_BLOCK_INDICES[randomIndex];

    let shape = BASE_BLOCK_SHAPES[baseShapeIndex];
    
    // 0åº¦ã€90åº¦ã€180åº¦ã€270åº¦ã®ã„ãšã‚Œã‹ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é¸æŠ (0ã€œ3å›ã®å›è»¢)
    const rotations = Math.floor(Math.random() * 4); 

    for (let i = 0; i < rotations; i++) {
        shape = rotateShape(shape);
    }
    
    return shape;
}

        function generateNewBlocks() {
            currentBlocks = [];
            for (let i = 0; i < 3; i++) {
                currentBlocks.push(getRandomBlockShape());
            }
            drawCurrentBlocks();
        }

        function replaceBlock(index) {
            currentBlocks[index] = getRandomBlockShape();
        }

        function drawCurrentBlocks() {
            const blocksEl = document.getElementById('current-blocks');
            blocksEl.innerHTML = '';

            currentBlocks.forEach((shape, index) => {
                const previewEl = document.createElement('div');
                previewEl.classList.add('block-preview');
                previewEl.draggable = true;
                previewEl.dataset.index = index;

                // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
                previewEl.addEventListener('dragstart', handleDragStart);
                previewEl.addEventListener('dragend', cleanupDragState); 

                // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆ
                previewEl.addEventListener('touchstart', handleTouchStart);

                shape.forEach(row => {
                    const rowEl = document.createElement('div');
                    rowEl.classList.add('block-row');
                    row.forEach(cellValue => {
                        const cellEl = document.createElement('div');
                        cellEl.classList.add('block-cell');
                        if (cellValue === 1) {
                            cellEl.classList.add('active');
                        }
                        rowEl.appendChild(cellEl);
                    });
                    previewEl.appendChild(rowEl);
                });

                blocksEl.appendChild(previewEl);
            });
        }

        // --- 6. å…±é€šã®é…ç½®ãƒ­ã‚¸ãƒƒã‚¯ã¨ãƒã‚¤ãƒ©ã‚¤ãƒˆå‡¦ç† ---
        
        /**
         * ãƒã‚¤ãƒ³ã‚¿ãƒ¼ä½ç½®ã®ã‚»ãƒ«ã‹ã‚‰ã€é…ç½®ã®åŸºæº–ã¨ãªã‚‹å·¦ä¸Šã‚¢ãƒ³ã‚«ãƒ¼åº§æ¨™ã‚’è¨ˆç®—ã™ã‚‹
         * @param {HTMLElement} centerCell ãƒã‚¤ãƒ³ã‚¿ãƒ¼ä¸‹ã®ã‚»ãƒ«
         * @param {number[][]} blockShape ãƒ–ãƒ­ãƒƒã‚¯å½¢çŠ¶
         * @returns {{targetR: number, targetC: number} | null}
         */
        function calculateAnchor(centerCell, blockShape) {
            if (!centerCell) return null;

            // ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãŒç¾åœ¨æŒ‡ã—ã¦ã„ã‚‹ã‚»ãƒ«ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã®ã€Œä¸­å¿ƒã€ã¨è¦‹ãªã™
            const centerR = parseInt(centerCell.dataset.row);
            const centerC = parseInt(centerCell.dataset.col);

            const blockRows = blockShape.length;
            const blockCols = blockShape[0].length;
            
            // ä¸­å¿ƒã‚»ãƒ«ã‹ã‚‰å·¦ä¸Šã‚¢ãƒ³ã‚«ãƒ¼ã‚»ãƒ«ã¸ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—
            const offsetR = Math.floor(blockRows / 2);
            const offsetC = Math.floor(blockCols / 2);

            let anchorR = centerR - offsetR;
            let anchorC = centerC - offsetC;

            // å¢ƒç•Œã®ã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°ï¼šãƒ–ãƒ­ãƒƒã‚¯å…¨ä½“ãŒãƒœãƒ¼ãƒ‰å†…ã«åã¾ã‚‹ã‚ˆã†ã«èª¿æ•´
            // 1. ä¸Šå¢ƒç•Œ (è¡Œ >= 0)
            anchorR = Math.max(0, anchorR);
            // 2. ä¸‹å¢ƒç•Œ (è¡Œ + é«˜ã• <= BOARD_SIZE)
            anchorR = Math.min(anchorR, BOARD_SIZE - blockRows);
            
            // 3. å·¦å¢ƒç•Œ (åˆ— >= 0)
            anchorC = Math.max(0, anchorC);
            // 4. å³å¢ƒç•Œ (åˆ— + å¹… <= BOARD_SIZE)
            anchorC = Math.min(anchorC, BOARD_SIZE - blockCols);

            return { targetR: anchorR, targetC: anchorC };
        }

        // å…¨ã¦ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’è§£é™¤ã™ã‚‹
        function removeAllHighlights() {
            document.querySelectorAll('.potential-placement').forEach(el => el.classList.remove('potential-placement'));
        }

        // ãƒ–ãƒ­ãƒƒã‚¯ã®å½¢ã«åˆã‚ã›ã¦ã‚»ãƒ«ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ/è§£é™¤ã™ã‚‹
        function highlightCells(startR, startC, shape, isAdding) {
            const boardEl = document.getElementById('board');
            const rows = shape.length;
            const cols = shape[0].length;
            
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (shape[r][c] === 1) {
                        const boardR = startR + r;
                        const boardC = startC + c;

                        const cell = boardEl.querySelector(`.cell[data-row="${boardR}"][data-col="${boardC}"]`);
                        if (cell) {
                            if (isAdding) {
                                cell.classList.add('potential-placement');
                            } else {
                                cell.classList.remove('potential-placement');
                            }
                        }
                    }
                }
            }
        }


        function tryPlaceBlock(targetR, targetC, blockShape, blockIndex) {
            if (isGameOver) return false;

            if (canPlaceBlock(targetR, targetC, blockShape)) {
                placeBlock(targetR, targetC, blockShape); 
                
                drawBoard(); 

                replaceBlock(blockIndex); 
                
                checkAndClearLines(); 
                
                drawCurrentBlocks(); 
                checkGameOver(); 
                return true;
            }
            return false;
        }
        
        function cleanupDragState() {
            document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
            removeAllHighlights(); 
            selectedBlockIndex = -1;
            
            if (draggedBlockGhost) {
                draggedBlockGhost.remove();
                draggedBlockGhost = null;
            }
            currentTargetCell = null;
            
            // ãƒã‚¦ã‚¹ãƒ‰ãƒ©ãƒƒã‚°ç”¨ã®ã‚¢ãƒ³ã‚«ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚‚ã‚¯ãƒªã‚¢
            const boardEl = document.getElementById('board');
            delete boardEl.dataset.anchorR;
            delete boardEl.dataset.anchorC;
        }
        
        // --- 7. ãƒã‚¦ã‚¹ãƒ‰ãƒ©ãƒƒã‚°å‡¦ç† ---

        function handleDragStart(e) {
            if (isGameOver) {
                e.preventDefault();
                return;
            }
            const previewEl = e.target.closest('.block-preview');
            const index = parseInt(previewEl.dataset.index);
            if (isNaN(index)) return;

            selectedBlockIndex = index;
            e.dataTransfer.setData('text/plain', selectedBlockIndex);
            previewEl.classList.add('dragging');

            document.getElementById('board').addEventListener('dragover', handleBoardDragOver);
        }

        function handleBoardDragOver(e) {
            e.preventDefault();
            
            if (selectedBlockIndex === -1 || isGameOver) return; 

            // ãƒã‚¦ã‚¹åº§æ¨™ã‹ã‚‰è¦ç´ ã‚’å–å¾—
            const elementUnderMouse = document.elementFromPoint(e.clientX, e.clientY);
            const centerCell = elementUnderMouse ? elementUnderMouse.closest('.cell') : null;
            const blockShape = currentBlocks[selectedBlockIndex];
            
            removeAllHighlights(); // å¤ã„ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’ã‚¯ãƒªã‚¢

            if (centerCell) {
                // æ–°ã—ã„ã‚¢ãƒ³ã‚«ãƒ¼ã‚’è¨ˆç®—
                const anchor = calculateAnchor(centerCell, blockShape);
                
                if (anchor && canPlaceBlock(anchor.targetR, anchor.targetC, blockShape)) {
                    highlightCells(anchor.targetR, anchor.targetC, blockShape, true); // æ–°ã—ã„ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’é©ç”¨
                    
                    // ãƒ‰ãƒ­ãƒƒãƒ—ã‚¤ãƒ™ãƒ³ãƒˆç”¨ã«ã‚¢ãƒ³ã‚«ãƒ¼åº§æ¨™ã‚’ãƒœãƒ¼ãƒ‰è¦ç´ ã«ä¸€æ™‚ä¿å­˜
                    document.getElementById('board').dataset.anchorR = anchor.targetR;
                    document.getElementById('board').dataset.anchorC = anchor.targetC;

                } else {
                    delete document.getElementById('board').dataset.anchorR;
                    delete document.getElementById('board').dataset.anchorC;
                }
            } else {
                 delete document.getElementById('board').dataset.anchorR;
                 delete document.getElementById('board').dataset.anchorC;
            }
        }

        function allowDrop(e) {
            e.preventDefault();
        }

        function handleDrop(e) {
            e.preventDefault();
            document.getElementById('board').removeEventListener('dragover', handleBoardDragOver); // ãƒªã‚¹ãƒŠãƒ¼ã‚’è§£é™¤
            
            const boardEl = document.getElementById('board');
            const targetRow = parseInt(boardEl.dataset.anchorR);
            const targetCol = parseInt(boardEl.dataset.anchorC);

            // dragoverã§è¨ˆç®—ã•ã‚ŒãŸæœ‰åŠ¹ãªã‚¢ãƒ³ã‚«ãƒ¼ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            if (isNaN(targetRow) || isNaN(targetCol)) {
                document.getElementById('message').textContent = 'ãƒœãƒ¼ãƒ‰ä¸Šã®æœ‰åŠ¹ãªä½ç½®ã«ãƒ‰ãƒ­ãƒƒãƒ—ã—ã¦ãã ã•ã„ã€‚';
                cleanupDragState();
                return;
            }

            const blockShape = currentBlocks[selectedBlockIndex];

            if (blockShape && tryPlaceBlock(targetRow, targetCol, blockShape, selectedBlockIndex)) {
                // æˆåŠŸ
            } else {
                document.getElementById('message').textContent = 'ãã®ä½ç½®ã«ã¯ç½®ã‘ã¾ã›ã‚“ï¼';
            }

            cleanupDragState();
        }

        // --- 8. ã‚¿ãƒƒãƒï¼†ã‚¹ãƒ¯ã‚¤ãƒ—å‡¦ç† ---

        function handleTouchStart(e) {
            if (isGameOver) return;
            e.preventDefault(); 

            const previewEl = e.target.closest('.block-preview');
            const index = parseInt(previewEl.dataset.index);
            if (isNaN(index)) return;

            selectedBlockIndex = index;
            previewEl.classList.add('dragging');
            
            // ã‚´ãƒ¼ã‚¹ãƒˆè¦ç´ ã‚’ä½œæˆ
            draggedBlockGhost = previewEl.cloneNode(true);
            draggedBlockGhost.classList.remove('block-preview', 'dragging');
            draggedBlockGhost.classList.add('ghost-block');
            document.body.appendChild(draggedBlockGhost);

            // ã‚¿ãƒƒãƒä½ç½®ã«ã‚´ãƒ¼ã‚¹ãƒˆã‚’é…ç½®
            const touch = e.touches[0];
            
            draggedBlockGhost.style.left = `${touch.clientX - (draggedBlockGhost.offsetWidth / 2)}px`;
            draggedBlockGhost.style.top = `${touch.clientY - (draggedBlockGhost.offsetHeight / 2)}px`;

            // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªç§»å‹•/çµ‚äº†ãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®š
            document.addEventListener('touchmove', handleTouchMove);
            document.addEventListener('touchend', handleTouchEnd);
        }

        function handleTouchMove(e) {
            e.preventDefault(); 

            const touch = e.touches[0];
            if (!draggedBlockGhost) return;

            // ã‚´ãƒ¼ã‚¹ãƒˆã‚’æŒ‡ã®ä½ç½®ã«è¿½å¾“ã•ã›ã‚‹
            draggedBlockGhost.style.left = `${touch.clientX - (draggedBlockGhost.offsetWidth / 2)}px`;
            draggedBlockGhost.style.top = `${touch.clientY - (draggedBlockGhost.offsetHeight / 2)}px`;

            // ç¾åœ¨æŒ‡ã®ä¸‹ã«ã‚ã‚‹è¦ç´ ã‚’å–å¾—
            const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
            const centerCell = elementUnderTouch ? elementUnderTouch.closest('.cell') : null;
            const blockShape = currentBlocks[selectedBlockIndex];

            // ãƒã‚¤ãƒ©ã‚¤ãƒˆæ›´æ–°ãƒ­ã‚¸ãƒƒã‚¯
            removeAllHighlights(); 
            
            if (centerCell) {
                // æ–°ã—ã„ã‚¢ãƒ³ã‚«ãƒ¼ã‚’è¨ˆç®—
                const anchor = calculateAnchor(centerCell, blockShape);
                
                if (anchor && canPlaceBlock(anchor.targetR, anchor.targetC, blockShape)) {
                    // é…ç½®å¯èƒ½ãªå ´åˆã¯ã€ãƒ–ãƒ­ãƒƒã‚¯ã®å½¢å…¨ä½“ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                    highlightCells(anchor.targetR, anchor.targetC, blockShape, true);
                    currentTargetCell = anchor; // ãƒ‰ãƒ­ãƒƒãƒ—ãŒæœ‰åŠ¹ãªã‚¢ãƒ³ã‚«ãƒ¼åº§æ¨™ã‚’è¨˜éŒ²
                } else {
                    currentTargetCell = null; // é…ç½®ä¸å¯
                }
            } else {
                currentTargetCell = null; // ãƒœãƒ¼ãƒ‰å¤–
            }
        }

        function handleTouchEnd(e) {
            document.removeEventListener('touchmove', handleTouchMove);
            document.removeEventListener('touchend', handleTouchEnd);
            
            // ãƒ‰ãƒ­ãƒƒãƒ—å‡¦ç†
            if (currentTargetCell) { // currentTargetCellã¯ã‚¢ãƒ³ã‚«ãƒ¼åº§æ¨™ {targetR, targetC} ã‚’ä¿æŒ
                const { targetR, targetC } = currentTargetCell;
                const blockShape = currentBlocks[selectedBlockIndex];

                if (blockShape && tryPlaceBlock(targetR, targetC, blockShape, selectedBlockIndex)) {
                    // æˆåŠŸ
                } else {
                    document.getElementById('message').textContent = 'ãƒ‰ãƒ­ãƒƒãƒ—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚';
                }
            } else {
                 document.getElementById('message').textContent = 'ãƒœãƒ¼ãƒ‰ä¸Šã®æœ‰åŠ¹ãªãƒã‚¹ã«é…ç½®ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚';
            }

            // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            cleanupDragState();
        }

        // --- 9. é…ç½®ã¨æ¶ˆå»ã®ãƒ­ã‚¸ãƒƒã‚¯ ---

        function canPlaceBlock(startR, startC, shape) {
            const rows = shape.length;
            const cols = shape[0].length;

            if (startR + rows > BOARD_SIZE || startC + cols > BOARD_SIZE) {
                return false;
            }

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (shape[r][c] === 1) {
                        const boardR = startR + r;
                        const boardC = startC + c;
                        
                        // æ—¢ã«ãƒ–ãƒ­ãƒƒã‚¯ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                        if (board[boardR][boardC] === 1) {
                            return false; 
                        }
                    }
                }
            }
            return true;
        }

        function placeBlock(startR, startC, shape) {
            let placedCount = 0;
            for (let r = 0; r < shape.length; r++) {
                for (let c = 0; c < shape[0].length; c++) {
                    if (shape[r][c] === 1) {
                        board[startR + r][startC + c] = 1;
                        placedCount++;
                    }
                }
            }
            score += placedCount * 1; 
            document.getElementById('score').textContent = score;
        }

        function checkAndClearLines() {
            let linesToClear = [];

            // 1. è¡Œã¨åˆ—ã®ãƒã‚§ãƒƒã‚¯ã®ã¿ã‚’è¡Œã†
            for (let i = 0; i < BOARD_SIZE; i++) {
                // è¡Œãƒã‚§ãƒƒã‚¯
                if (board[i].every(cell => cell === 1)) {
                    linesToClear.push({ type: 'row', index: i });
                }
                // åˆ—ãƒã‚§ãƒƒã‚¯
                if (board.every(row => row[i] === 1)) {
                    linesToClear.push({ type: 'col', index: i });
                }
            }

            // 3. æ¶ˆå»å‡¦ç†ã¨ã‚¹ã‚³ã‚¢è¨ˆç®—
            if (linesToClear.length > 0) {
                let uniqueClearedCells = new Set();
                const clearedLines = linesToClear.length;

                linesToClear.forEach(line => {
                    if (line.type === 'row') {
                        for (let c = 0; c < BOARD_SIZE; c++) {
                            uniqueClearedCells.add(`${line.index},${c}`);
                            board[line.index][c] = 0;
                        }
                    } else if (line.type === 'col') {
                        for (let r = 0; r < BOARD_SIZE; r++) {
                            uniqueClearedCells.add(`${r},${line.index}`);
                            board[r][line.index] = 0;
                        }
                    }
                });

                // ã‚¹ã‚³ã‚¢è¨ˆç®—ã¨ã‚³ãƒ³ãƒœãƒœãƒ¼ãƒŠã‚¹
                score += uniqueClearedCells.size * 10;
                if (clearedLines > 1) {
                    score += clearedLines * 50; 
                    document.getElementById('message').textContent = `ğŸ’¥ ${clearedLines} ã‚³ãƒ³ãƒœï¼ (+${clearedLines * 50}) ğŸ’¥`;
                } else {
                    document.getElementById('message').textContent = `âœ… ãƒ©ã‚¤ãƒ³ã‚¯ãƒªã‚¢ï¼`;
                }

                document.getElementById('score').textContent = score;
                // ã‚¯ãƒªã‚¢ã‚’åæ˜ ã•ã›ã‚‹
                drawBoard(); 
            } else {
                document.getElementById('message').textContent = 'æ¬¡ã®é…ç½®ã‚’è€ƒãˆã¾ã—ã‚‡ã†ã€‚';
            }
        }

// --- 10. ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒã‚§ãƒƒã‚¯ ---

function checkGameOver() {
    // ... (é…ç½®å¯èƒ½ãƒã‚§ãƒƒã‚¯ã®ãƒ­ã‚¸ãƒƒã‚¯ã¯å¤‰æ›´ãªã—)
    for (const shape of currentBlocks) {
        // ãƒ–ãƒ­ãƒƒã‚¯ãŒã¾ã å­˜åœ¨ã™ã‚‹ã‹ï¼ˆã‚¯ãƒªã‚¢ã•ã‚Œã¦ã„ãªã„ã‹ï¼‰ç¢ºèª
        if (shape === null) continue; 
        
        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                if (canPlaceBlock(r, c, shape)) {
                    return; // é…ç½®å¯èƒ½ãªå ´æ‰€ãŒè¦‹ã¤ã‹ã£ãŸãŸã‚ã€ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã§ã¯ãªã„
                }
            }
        }
    }
    
    // å…¨ã¦ã®ãƒ–ãƒ­ãƒƒã‚¯ãŒé…ç½®ä¸èƒ½ã®å ´åˆã€ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼å‡¦ç†ã‚’é…å»¶å®Ÿè¡Œã™ã‚‹
    
    // 1. ãƒ•ãƒ©ã‚°ã¯ã™ãã«ç«‹ã¦ã‚‹ (ã“ã‚Œä»¥ä¸Šæ“ä½œã•ã›ãªã„ãŸã‚)
    isGameOver = true;
    
    // 2. 0.5ç§’ã®ãƒ‡ã‚£ãƒ¬ã‚¤ã‚’è¨­å®š
    setTimeout(() => {
        // 3. 0.5ç§’å¾Œã«ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã®è¡¨ç¤ºã¨ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’å®Ÿè¡Œ
        document.getElementById('message').style.color = '#d32f2f';
        document.getElementById('message').textContent = `ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼æœ€çµ‚ã‚¹ã‚³ã‚¢: ${score}`;
        document.getElementById('current-blocks').innerHTML = '<p style="color: #6b4c3e; font-weight: bold;">ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã§ã™ã€‚ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã§å†é–‹ã—ã¦ãã ã•ã„ã€‚</p>';
    }, 500); // 500ãƒŸãƒªç§’ = 0.5ç§’
}

        // ã‚²ãƒ¼ãƒ é–‹å§‹
        document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>

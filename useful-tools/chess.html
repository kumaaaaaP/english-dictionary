<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>chess</title>
    <!-- Tailwind CSS CDNã‚’èª­ã¿è¾¼ã¿ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Interãƒ•ã‚©ãƒ³ãƒˆã‚’ä½¿ç”¨ -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
        }
        .container-wrapper {
            max-width: 640px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .chessboard-container {
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            overflow: hidden;
            width: 100%;
            margin-top: 20px;
        }
        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            aspect-ratio: 1 / 1;
            /* ç›¤é¢ã®å›è»¢ã‚’å›ºå®š */
            transform: rotate(0deg); 
            transition: transform 0.5s ease;
        }
        .square {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(30px, 5vw, 60px);
            cursor: pointer;
            transition: background-color 0.2s ease;
            position: relative;
        }
        .piece {
            user-select: none;
            line-height: 1;
            transition: transform 0.3s ease; /* é§’ã®å›è»¢ç”¨ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ */
        }
        /* ç›¤é¢/é§’ã®å›è»¢é–¢é€£ã®CSSã‚’å‰Šé™¤ã—ã¾ã—ãŸ (.board.flipped, .board.flipped .square > span) */

        .light { background-color: #f0d9b5; }
        .dark { background-color: #b58863; }
        .selected { background-color: #55a855 !important; }
        .highlight { background-color: rgba(69, 137, 237, 0.5) !important; }
        .possible-move::after {
            content: '';
            display: block;
            width: 30%;
            height: 30%;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
        }
        .possible-capture {
            position: relative;
            border: 4px solid #d00000;
            box-sizing: border-box;
            border-radius: 4px;
        }
        
        #message-box {
            min-height: 4rem;
            text-align: center;
            padding: 0.75rem;
            margin-bottom: 1.25rem;
            border-radius: 8px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .white-turn { background-color: #fff; color: #333; border: 2px solid #333; }
        .black-turn { background-color: #333; color: #fff; border: 2px solid #fff; }
        .check-status { background-color: #fecaca; color: #dc2626; border: 3px solid #ef4444; }
        .game-over { background-color: #d00000; color: #fff; animation: pulse 1.5s infinite; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* --- ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚¹ã‚¿ã‚¤ãƒ« --- */
        #promotion-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        .promotion-content {
            background-color: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            text-align: center;
        }
        .promotion-button {
            width: 70px;
            height: 70px;
            margin: 5px;
            font-size: 40px;
            border-radius: 8px;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            background-color: #e0e7ff;
            color: #312e81;
            font-weight: bold;
            transition: all 0.2s;
            cursor: pointer;
        }
        .promotion-button:hover {
            background-color: #c7d2fe;
            transform: scale(1.05);
        }
    </style>
    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° (FENé–¢é€£ã®çŠ¶æ…‹ã‚’å«ã‚€)
        let board = [];
        let currentPlayer = 'white';
        let selectedSquare = null; // [r, c]
        let possibleMoves = []; // Array of {r, c, type: 'normal'|'castle_ks'|'castle_qs'|'en_passant'}
        let gameStatus = 'playing';

        // FENé–¢é€£ã®çŠ¶æ…‹
        let castlingRights = 'KQkq'; // K: White KS, Q: White QS, k, q: Black
        let enPassantTarget = '-'; // e.g., 'e3' (algebraic notation) or '-'
        let halfMoveClock = 0; // Moves since last pawn move or capture (for 50-move rule)
        let fullMoveNumber = 1;
        let fenHistory = {}; // FEN counts for Threefold Repetition

        // é§’ã®Unicodeè¨˜å·
        const pieces = {
            'wP': 'â™™', 'wN': 'â™˜', 'wB': 'â™—', 'wR': 'â™–', 'wQ': 'â™•', 'wK': 'â™”',
            'bP': 'â™Ÿ', 'bN': 'â™', 'bB': 'â™', 'bR': 'â™œ', 'bQ': 'â™›', 'bK': 'â™š'
        };

        // --- FEN / ä»£æ•°è¡¨è¨˜ ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•° ---
        function toAlgebraic(r, c) {
            const file = String.fromCharCode(97 + c);
            const rank = 8 - r;
            return file + rank;
        }

        function toCoords(algebraic) {
            if (algebraic === '-') return null;
            const file = algebraic.charCodeAt(0) - 97;
            const rank = 8 - parseInt(algebraic[1]);
            return { r: rank, c: file };
        }
        
        // FENã‚’ç”Ÿæˆ (ä¸»è¦ãªè¦ç´ ã®ã¿)
        function generateFen() {
            let fen = '';
            for (let r = 0; r < 8; r++) {
                let emptyCount = 0;
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (!piece) {
                        emptyCount++;
                    } else {
                        if (emptyCount > 0) {
                            fen += emptyCount;
                            emptyCount = 0;
                        }
                        const p = piece[1];
                        fen += piece[0] === 'w' ? p.toUpperCase() : p.toLowerCase();
                    }
                }
                if (emptyCount > 0) fen += emptyCount;
                if (r < 7) fen += '/';
            }
            // ç›¤é¢ã€æ‰‹ç•ªã€ã‚­ãƒ£ã‚¹ãƒªãƒ³ã‚°æ¨©ã€ã‚¢ãƒ³ãƒ‘ãƒƒã‚µãƒ³ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ
            return `${fen} ${currentPlayer[0]} ${castlingRights} ${enPassantTarget}`;
        }
        
        // --- ã‚²ãƒ¼ãƒ åˆæœŸåŒ– ---
        function initializeBoard() {
            // åˆæœŸé…ç½®ã®FEN
            const initialFen = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
            const [boardFen, turn, rights, epTarget, halfMove, fullMove] = initialFen.split(' ');
            const rows = boardFen.split('/');
            
            board = Array(8).fill(0).map(() => Array(8).fill(null));

            for (let r = 0; r < 8; r++) {
                let c = 0;
                for (const char of rows[r]) {
                    if (char >= '1' && char <= '8') {
                        c += parseInt(char);
                    } else {
                        const color = char === char.toUpperCase() ? 'w' : 'b';
                        const type = char.toUpperCase();
                        board[r][c] = color + type;
                        c++;
                    }
                }
            }

            // çŠ¶æ…‹ã®åˆæœŸåŒ–
            gameStatus = 'playing';
            currentPlayer = turn === 'w' ? 'white' : 'black';
            castlingRights = rights;
            enPassantTarget = epTarget;
            halfMoveClock = parseInt(halfMove);
            fullMoveNumber = parseInt(fullMove);
            selectedSquare = null;
            possibleMoves = [];
            fenHistory = {}; // å±¥æ­´ãƒªã‚»ãƒƒãƒˆ
            
            updateBoardDisplay();
            updateMessage(`${currentPlayer === 'white' ? 'ç™½' : 'é»’'}ã®æ‰‹ç•ªã§ã™ã€‚`);
        }

        // --- UIæ›´æ–° ---
        function updateBoardDisplay() {
            const boardElement = document.getElementById('chessboard');
            boardElement.innerHTML = '';
            
            // ç›¤é¢ã®å›è»¢ã¯ç„¡åŠ¹ï¼ˆç™½ç•ªè¦–ç‚¹å›ºå®šï¼‰
            
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const isLight = (r + c) % 2 === 0;
                    const square = document.createElement('div');
                    square.id = `sq-${r}-${c}`;
                    square.className = `square ${isLight ? 'light' : 'dark'} transition-all`;
                    square.dataset.row = r;
                    square.dataset.col = c;
                    square.addEventListener('click', () => handleSquareClick(r, c));

                    const pieceCode = board[r][c];
                    if (pieceCode) {
                        const pieceElement = document.createElement('span');
                        pieceElement.className = 'piece';
                        pieceElement.textContent = pieces[pieceCode];
                        pieceElement.style.color = pieceCode.startsWith('w') ? '#fff' : '#000';
                        pieceElement.style.textShadow = pieceCode.startsWith('w') ? '0 0 4px #000' : '0 0 4px #fff';

                        // --- ä¿®æ­£ç®‡æ‰€: é»’ã®é§’ã®ã¿180åº¦å›è»¢ ---
                        if (pieceCode.startsWith('b')) {
                            pieceElement.style.transform = 'rotate(180deg)';
                        } else {
                            pieceElement.style.transform = 'rotate(0deg)';
                        }
                        // ------------------------------------

                        square.appendChild(pieceElement);
                    }
                    boardElement.appendChild(square);
                }
            }
        }
        
        function updateMessage(text, isGameOver = false, isCheck = false) {
            const messageBox = document.getElementById('message-box');
            messageBox.textContent = text;
            messageBox.className = 'w-full mb-5 rounded-lg shadow-md';
            
            if (isGameOver) {
                messageBox.classList.add('game-over');
            } else if (isCheck) {
                messageBox.classList.add('check-status');
            } else if (currentPlayer === 'white') {
                messageBox.classList.add('white-turn');
            } else {
                messageBox.classList.add('black-turn');
            }
        }

        function clearHighlights() {
            document.querySelectorAll('.square').forEach(sq => {
                sq.classList.remove('selected', 'highlight', 'possible-move', 'possible-capture');
            });
        }
        
        // --- ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯ ---
        
        function handleSquareClick(r, c) {
            if (gameStatus !== 'playing') return;

            const piece = board[r][c];
            const clickedPieceColor = piece ? piece[0] === 'w' ? 'white' : 'black' : null;

            if (selectedSquare) {
                const [sr, sc] = selectedSquare;
                const move = possibleMoves.find(m => m.r === r && m.c === c);

                if (move) {
                    // æœ‰åŠ¹ãªç§»å‹•ã‚’å®Ÿè¡Œ
                    performMove(sr, sc, r, c, move.type);
                    selectedSquare = null;
                    possibleMoves = [];
                    clearHighlights();
                    
                    // ãƒ—ãƒ­ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ãŒå¿…è¦ãªå ´åˆã¯å¾…æ©Ÿ
                    if (move.type === 'promotion') {
                        showPromotionModal(r, c);
                    } else {
                        // æ¬¡ã®æ‰‹ç•ªã¸
                        currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
                        checkGameStatus();
                    }

                } else if (clickedPieceColor === currentPlayer) {
                    // æ—¢ã«é¸æŠã•ã‚Œã¦ã„ã‚‹é§’ã¨åŒã˜è‰²ã®åˆ¥ã®é§’ã‚’é¸æŠ
                    selectedSquare = [r, c];
                    showPossibleMoves(r, c);
                } else {
                    // ç§»å‹•ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã¾ãŸã¯ç„¡åŠ¹ãªã‚¿ãƒ¼ã‚²ãƒƒãƒˆ
                    selectedSquare = null;
                    possibleMoves = [];
                    clearHighlights();
                    checkGameStatus(); // é€šå¸¸ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«æˆ»ã™
                }
            } else if (clickedPieceColor === currentPlayer) {
                // è‡ªåˆ†ã®é§’ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦é¸æŠ
                selectedSquare = [r, c];
                showPossibleMoves(r, c);
            }
        }

        // é§’ã®ç§»å‹•ã‚’å®Ÿè¡Œã—ã€ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’æ›´æ–°
        function performMove(sr, sc, dr, dc, moveType) {
            const pieceCode = board[sr][sc];
            const pieceType = pieceCode[1];
            const isPawnMoveOrCapture = (pieceType === 'P' || board[dr][dc] !== null);
            
            // çŠ¶æ…‹æ›´æ–° (ãƒãƒ¼ãƒ•ãƒ ãƒ¼ãƒ–ã‚¯ãƒ­ãƒƒã‚¯ã¨ãƒ•ãƒ«ãƒ ãƒ¼ãƒ–)
            if (isPawnMoveOrCapture) {
                halfMoveClock = 0;
            } else {
                halfMoveClock++;
            }
            if (currentPlayer === 'black') {
                fullMoveNumber++;
            }

            // 1. ã‚­ãƒ£ã‚¹ãƒªãƒ³ã‚°ã®å‡¦ç†
            if (moveType === 'castle_kingside') {
                const rookR = sr;
                const rookC = 7;
                board[dr][dc] = pieceCode; // King to g1/g8
                board[sr][sc] = null;
                board[rookR][5] = board[rookR][rookC]; // Rook to f1/f8
                board[rookR][rookC] = null;
            } else if (moveType === 'castle_queenside') {
                const rookR = sr;
                const rookC = 0;
                board[dr][dc] = pieceCode; // King to c1/c8
                board[sr][sc] = null;
                board[rookR][3] = board[rookR][rookC]; // Rook to d1/d8
                board[rookR][rookC] = null;
            } 
            // 2. ã‚¢ãƒ³ãƒ‘ãƒƒã‚µãƒ³ã®å‡¦ç†
            else if (moveType === 'en_passant') {
                const capturedR = currentPlayer === 'white' ? dr + 1 : dr - 1;
                board[capturedR][dc] = null; // ç›¸æ‰‹ã®ãƒãƒ¼ãƒ³ã‚’å‰Šé™¤
                board[dr][dc] = pieceCode;
                board[sr][sc] = null;
            }
            // 3. é€šå¸¸ã®ç§»å‹• (ãƒ—ãƒ­ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã¯ makeMove ã§ã¯å‡¦ç†ã—ãªã„)
            else {
                board[dr][dc] = pieceCode;
                board[sr][sc] = null;
            }

            // 4. ã‚­ãƒ£ã‚¹ãƒªãƒ³ã‚°æ¨©ã®æ›´æ–°
            if (pieceCode === 'wK') { castlingRights = castlingRights.replace(/[KQ]/g, ''); }
            if (pieceCode === 'bK') { castlingRights = castlingRights.replace(/[kq]/g, ''); }
            if (pieceCode === 'wR') {
                if (sr === 7 && sc === 0) castlingRights = castlingRights.replace('Q', '');
                if (sr === 7 && sc === 7) castlingRights = castlingRights.replace('K', '');
            }
            if (pieceCode === 'bR') {
                if (sr === 0 && sc === 0) castlingRights = castlingRights.replace('q', '');
                if (sr === 0 && sc === 7) castlingRights = castlingRights.replace('k', '');
            }

            // 5. ã‚¢ãƒ³ãƒ‘ãƒƒã‚µãƒ³ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®æ›´æ–°
            if (pieceType === 'P' && Math.abs(dr - sr) === 2) {
                const targetR = currentPlayer === 'white' ? sr - 1 : sr + 1;
                enPassantTarget = toAlgebraic(targetR, sc);
            } else {
                enPassantTarget = '-';
            }

            // ã‚­ãƒ£ã‚¹ãƒªãƒ³ã‚°æ¨©ãŒãªã„å ´åˆã¯'-'ã«
            if (castlingRights === '') castlingRights = '-';
            
            // FENå±¥æ­´ã®è¿½è·¡ (Threefold Repetition ã®ãŸã‚ã«ã€ãƒãƒ¼ãƒ•ãƒ ãƒ¼ãƒ–ã‚¯ãƒ­ãƒƒã‚¯ã‚’å«ã‚€FENã®æœ€åˆã®4è¦ç´ ã‚’è¨˜éŒ²)
            const currentFenKey = generateFen(); 
            fenHistory[currentFenKey] = (fenHistory[currentFenKey] || 0) + 1;

            updateBoardDisplay();
        }

        // --- é§’ã®ç§»å‹•ãƒ­ã‚¸ãƒƒã‚¯ (ã‚­ãƒ³ã‚°ã®å®‰å…¨æ€§ã‚’ç¢ºèª) ---
        
        function findKing(currentBoard, color) {
            const kingCode = color + 'K';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (currentBoard[r][c] === kingCode) {
                        return { r, c };
                    }
                }
            }
            return null;
        }

        function isKingInCheck(currentBoard, color) {
            const kingPos = findKing(currentBoard, color[0].toLowerCase());
            if (!kingPos) return false;

            const opponentColor = color === 'white' ? 'black' : 'white';

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const pieceCode = currentBoard[r][c];
                    if (pieceCode && pieceCode.startsWith(opponentColor[0].toLowerCase())) {
                        // ç›¸æ‰‹ã®é§’ã®ã™ã¹ã¦ã®ã€Œæ½œåœ¨çš„ãªã€ç§»å‹• (ã‚­ãƒ£ã‚¹ãƒªãƒ³ã‚°/EP/ã‚­ãƒ³ã‚°ã®å®‰å…¨ãƒã‚§ãƒƒã‚¯ã¯ç„¡è¦–)
                        const opponentMoves = getPossibleMoves({r, c, pieceCode}, currentBoard, { ignoreKingSafety: true });

                        if (opponentMoves.some(move => move.r === kingPos.r && move.c === kingPos.c)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        function getPossibleMoves(piece, currentBoard, { ignoreKingSafety = false } = {}) {
            const { r: sr, c: sc, pieceCode } = piece;
            const pieceType = pieceCode[1];
            const pieceColor = pieceCode[0] === 'w' ? 'white' : 'black';
            const oppChar = pieceColor === 'white' ? 'b' : 'w';
            const myChar = pieceColor === 'white' ? 'w' : 'b';
            let rawMoves = [];

            // 1. é§’ã®ã‚¿ã‚¤ãƒ—ã«åŸºã¥ã„ãŸæœªåŠ å·¥ã®ç§»å‹•ã‚’ç”Ÿæˆ
            switch (pieceType) {
                case 'P': { // ãƒãƒ¼ãƒ³
                    const direction = pieceColor === 'white' ? -1 : 1;
                    const startRow = pieceColor === 'white' ? 6 : 1;
                    const promotionRow = pieceColor === 'white' ? 0 : 7;
                    
                    // å‰æ–¹1ãƒã‚¹
                    const r1 = sr + direction;
                    if (r1 >= 0 && r1 < 8 && !currentBoard[r1][sc]) {
                        const moveType = r1 === promotionRow ? 'promotion' : 'normal';
                        rawMoves.push({ r: r1, c: sc, type: moveType });
                        
                        // åˆæœŸä½ç½®ã‹ã‚‰ã®2ãƒã‚¹ç§»å‹•
                        const r2 = sr + 2 * direction;
                        if (sr === startRow && !currentBoard[r2][sc]) {
                            rawMoves.push({ r: r2, c: sc, type: 'normal' });
                        }
                    }

                    // æ”»æ’ƒï¼ˆæ–œã‚å‰ï¼‰
                    [-1, 1].forEach(dc => {
                        const tr = sr + direction;
                        const tc = sc + dc;
                        if (tr >= 0 && tr < 8 && tc >= 0 && tc < 8) {
                            const targetPiece = currentBoard[tr][tc];
                            const moveType = tr === promotionRow ? 'promotion' : 'normal';

                            // é€šå¸¸ã‚­ãƒ£ãƒ—ãƒãƒ£
                            if (targetPiece && targetPiece.startsWith(oppChar)) {
                                rawMoves.push({ r: tr, c: tc, type: moveType });
                            }
                            // ã‚¢ãƒ³ãƒ‘ãƒƒã‚µãƒ³
                            const epTargetCoords = toCoords(enPassantTarget);
                            if (epTargetCoords && epTargetCoords.r === tr && epTargetCoords.c === tc) {
                                rawMoves.push({ r: tr, c: tc, type: 'en_passant' });
                            }
                        }
                    });
                    break;
                }
                case 'N': { // ãƒŠã‚¤ãƒˆ
                    const knightMoves = [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]];
                    knightMoves.forEach(([dr, dc]) => {
                        const tr = sr + dr;
                        const tc = sc + dc;
                        if (tr >= 0 && tr < 8 && tc >= 0 && tc < 8) {
                            const targetPiece = currentBoard[tr][tc];
                            if (!targetPiece || targetPiece.startsWith(oppChar)) {
                                rawMoves.push({ r: tr, c: tc, type: 'normal' });
                            }
                        }
                    });
                    break;
                }
                case 'B': // ãƒ“ã‚·ãƒ§ãƒƒãƒ—
                case 'R': // ãƒ«ãƒ¼ã‚¯
                case 'Q': { // ã‚¯ã‚¤ãƒ¼ãƒ³
                    const directions = [];
                    if (pieceType === 'R' || pieceType === 'Q') { directions.push(...[[0, 1], [0, -1], [1, 0], [-1, 0]]); }
                    if (pieceType === 'B' || pieceType === 'Q') { directions.push(...[[1, 1], [1, -1], [-1, 1], [-1, -1]]); }
                    
                    directions.forEach(([dr, dc]) => {
                        for (let step = 1; step < 8; step++) {
                            const tr = sr + dr * step;
                            const tc = sc + dc * step;

                            if (tr < 0 || tr >= 8 || tc < 0 || tc >= 8) break;

                            const targetPiece = currentBoard[tr][tc];
                            if (!targetPiece) {
                                rawMoves.push({ r: tr, c: tc, type: 'normal' });
                            } else {
                                if (targetPiece.startsWith(oppChar)) {
                                    rawMoves.push({ r: tr, c: tc, type: 'normal' });
                                }
                                break;
                            }
                        }
                    });
                    break;
                }
                case 'K': { // ã‚­ãƒ³ã‚°
                    const kingMoves = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]];
                    kingMoves.forEach(([dr, dc]) => {
                        const tr = sr + dr;
                        const tc = sc + dc;
                        if (tr >= 0 && tr < 8 && tc >= 0 && tc < 8) {
                            const targetPiece = currentBoard[tr][tc];
                            if (!targetPiece || targetPiece.startsWith(oppChar)) {
                                rawMoves.push({ r: tr, c: tc, type: 'normal' });
                            }
                        }
                    });

                    // ã‚­ãƒ£ã‚¹ãƒªãƒ³ã‚° (ã‚­ãƒ³ã‚°ã®å®‰å…¨æ€§ã‚’ç„¡è¦–ã™ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—)
                    if (!ignoreKingSafety) {
                        const row = pieceColor === 'white' ? 7 : 0;
                        const colorCode = pieceColor === 'white' ? 'K' : 'k';
                        const oppColor = pieceColor === 'white' ? 'black' : 'white';

                        // ã‚­ãƒ³ã‚°ãŒãƒã‚§ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã„
                        if (sr === row && sc === 4 && !isKingInCheck(currentBoard, pieceColor)) {
                            
                            // ã‚­ãƒ³ã‚°ã‚µã‚¤ãƒ‰ (K/k)
                            if (castlingRights.includes(colorCode)) {
                                // f1/f8, g1/g8 ãŒç©ºã€ã‹ã¤ãƒã‚§ãƒƒã‚¯ã•ã‚Œãªã„
                                if (!currentBoard[row][5] && !currentBoard[row][6]) {
                                    // f1/f8, g1/g8 ãŒæ”»æ’ƒã•ã‚Œã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯
                                    const pathSafe = [
                                        {r: row, c: 5}, 
                                        {r: row, c: 6}
                                    ].every(({r, c}) => !isSquareAttacked(currentBoard, oppColor, r, c));

                                    if (pathSafe && currentBoard[row][7] === myChar + 'R') {
                                        rawMoves.push({ r: row, c: 6, type: 'castle_kingside' });
                                    }
                                }
                            }

                            // ã‚¯ã‚¤ãƒ¼ãƒ³ã‚µã‚¤ãƒ‰ (Q/q)
                            if (castlingRights.includes(colorCode.toLowerCase())) {
                                // b1/b8, c1/c8, d1/d8 ãŒç©ºã€ã‹ã¤ c1/c8, d1/d8 ãŒãƒã‚§ãƒƒã‚¯ã•ã‚Œãªã„
                                if (!currentBoard[row][1] && !currentBoard[row][2] && !currentBoard[row][3]) {
                                    // c1/c8, d1/d8 ãŒæ”»æ’ƒã•ã‚Œã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯
                                    const pathSafe = [
                                        {r: row, c: 2}, 
                                        {r: row, c: 3}
                                    ].every(({r, c}) => !isSquareAttacked(currentBoard, oppColor, r, c));

                                    if (pathSafe && currentBoard[row][0] === myChar + 'R') {
                                        rawMoves.push({ r: row, c: 2, type: 'castle_queenside' });
                                    }
                                }
                            }
                        }
                    }
                    break;
                }
            }

            // 2. ã‚­ãƒ³ã‚°ã®å®‰å…¨æ€§ã®ãƒã‚§ãƒƒã‚¯ãƒ•ãƒ©ã‚°ã‚’ç„¡è¦–ã™ã‚‹å ´åˆã¯ã€æœªåŠ å·¥ã®ç§»å‹•ã‚’è¿”ã™
            if (ignoreKingSafety) {
                return rawMoves;
            }

            // 3. ã‚­ãƒ³ã‚°ã®å®‰å…¨æ€§ã‚’ç¢ºèªã™ã‚‹ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚° (ãƒ”ãƒ³ã‚’è€ƒæ…®)
            const legalMoves = [];
            rawMoves.forEach(move => {
                // ä»®ã«ç§»å‹•ã‚’å®Ÿè¡Œ (ç‰¹æ®Šç§»å‹•ã‚‚è€ƒæ…®ã—ãŸã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³)
                const tempBoard = simulateMove(currentBoard, sr, sc, move.r, move.c, move.type);

                // ç§»å‹•å¾Œã€ã‚­ãƒ³ã‚°ãŒãƒã‚§ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã„ã‹ã‚’ç¢ºèª
                if (!isKingInCheck(tempBoard, pieceColor)) {
                    legalMoves.push(move);
                }
            });

            return legalMoves;
        }
        
        // ç‰¹å®šã®ãƒã‚¹ãŒç‰¹å®šã®è‰²ã®é§’ã«ã‚ˆã£ã¦æ”»æ’ƒã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
        // isKingInCheckã®å†…éƒ¨ã§å¿…è¦
        function isSquareAttacked(currentBoard, attackerColor, targetR, targetC) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const pieceCode = currentBoard[r][c];
                    if (pieceCode && pieceCode.startsWith(attackerColor[0].toLowerCase())) {
                        
                        // ç›¸æ‰‹ã®é§’ã®ã™ã¹ã¦ã®ã€Œæ½œåœ¨çš„ãªã€ç§»å‹• (ã‚­ãƒ³ã‚°ã®å®‰å…¨æ€§ã®å†å¸°ãƒã‚§ãƒƒã‚¯ã¯ç„¡è¦–)
                        const opponentMoves = getPossibleMoves({r, c, pieceCode}, currentBoard, { ignoreKingSafety: true });

                        if (opponentMoves.some(move => move.r === targetR && move.c === targetC)) {
                            return true; // æ”»æ’ƒã•ã‚Œã¦ã„ã¾ã™
                        }
                    }
                }
            }
            return false;
        }

        // ç§»å‹•ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã—ã€æ–°ã—ã„ç›¤é¢ã‚’è¿”ã™
        function simulateMove(currentBoard, sr, sc, dr, dc, moveType) {
            const tempBoard = JSON.parse(JSON.stringify(currentBoard));
            const pieceCode = tempBoard[sr][sc];

            if (moveType === 'castle_kingside') {
                const rookR = sr;
                const rookC = 7;
                tempBoard[dr][dc] = pieceCode; 
                tempBoard[sr][sc] = null;
                tempBoard[rookR][5] = tempBoard[rookR][rookC];
                tempBoard[rookR][rookC] = null;
            } else if (moveType === 'castle_queenside') {
                const rookR = sr;
                const rookC = 0;
                tempBoard[dr][dc] = pieceCode;
                tempBoard[sr][sc] = null;
                tempBoard[rookR][3] = tempBoard[rookR][rookC];
                tempBoard[rookR][rookC] = null;
            } else if (moveType === 'en_passant') {
                const capturedR = currentPlayer === 'white' ? dr + 1 : dr - 1;
                tempBoard[capturedR][dc] = null;
                tempBoard[dr][dc] = pieceCode;
                tempBoard[sr][sc] = null;
            } else {
                tempBoard[dr][dc] = pieceCode;
                tempBoard[sr][sc] = null;
            }
            return tempBoard;
        }


        // å¯èƒ½ãªç§»å‹•ãƒã‚¹ã‚’è¡¨ç¤º
        function showPossibleMoves(r, c) {
            clearHighlights();
            const square = document.getElementById(`sq-${r}-${c}`);
            square.classList.add('selected');

            const pieceCode = board[r][c];
            if (!pieceCode) return;

            possibleMoves = getPossibleMoves({ r, c, pieceCode }, board);

            possibleMoves.forEach(move => {
                const targetSquare = document.getElementById(`sq-${move.r}-${move.c}`);
                if (targetSquare) {
                    targetSquare.classList.add('highlight');
                    
                    // ã‚­ãƒ£ãƒ—ãƒãƒ£ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ (ã‚¢ãƒ³ãƒ‘ãƒƒã‚µãƒ³ã€ã‚­ãƒ£ã‚¹ãƒªãƒ³ã‚°ã¯ã“ã“ã§ã¯ç‰¹åˆ¥æ‰±ã„ã—ãªã„)
                    if (board[move.r][move.c] || move.type === 'en_passant') {
                        targetSquare.classList.add('possible-capture');
                    } else if (move.type.startsWith('castle')) {
                        // ã‚­ãƒ£ã‚¹ãƒªãƒ³ã‚°ã¯é€šå¸¸ã®ç§»å‹•ã¨ã—ã¦ãƒãƒ¼ã‚¯
                        targetSquare.classList.add('possible-move');
                    } else {
                        targetSquare.classList.add('possible-move');
                    }
                }
            });
        }
        
        // --- ãƒ—ãƒ­ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¢ãƒ¼ãƒ€ãƒ« ---
        let promotionCoords = null;
        
        function showPromotionModal(r, c) {
            promotionCoords = { r, c };
            const modal = document.getElementById('promotion-modal');
            const color = currentPlayer[0];
            const pieceTypes = ['Q', 'R', 'B', 'N'];
            const modalContent = document.getElementById('promotion-options');
            modalContent.innerHTML = '';

            pieceTypes.forEach(type => {
                const button = document.createElement('button');
                button.className = 'promotion-button shadow-md hover:shadow-lg';
                button.textContent = pieces[color + type];
                button.onclick = () => handlePromotionChoice(type);
                modalContent.appendChild(button);
            });
            modal.style.display = 'flex';
        }

        function handlePromotionChoice(promoteTo) {
            const { r, c } = promotionCoords;
            const colorCode = currentPlayer[0];
            
            // ç›¤é¢ã«æ˜‡æ ¼å¾Œã®é§’ã‚’è¨­å®š
            board[r][c] = colorCode + promoteTo;
            
            document.getElementById('promotion-modal').style.display = 'none';
            promotionCoords = null;

            // ãƒ—ãƒ­ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³å¾Œã€æ¬¡ã®æ‰‹ç•ªã¸
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            updateBoardDisplay();
            checkGameStatus();
        }

        // --- ã‚²ãƒ¼ãƒ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒã‚§ãƒƒã‚¯ ---
        
        function checkGameStatus() {
            const opponent = currentPlayer === 'white' ? 'black' : 'white';
            let hasLegalMoves = false;
            let kingInCheck = isKingInCheck(board, currentPlayer);

            // 1. æœ‰åŠ¹ãªç§»å‹•ãŒã‚ã‚‹ã‹ç¢ºèª
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const pieceCode = board[r][c];
                    if (pieceCode && pieceCode.startsWith(currentPlayer[0].toLowerCase())) {
                        const moves = getPossibleMoves({ r, c, pieceCode }, board);
                        if (moves.length > 0) {
                            hasLegalMoves = true;
                            break;
                        }
                    }
                }
                if (hasLegalMoves) break;
            }

            // 2. ã‚²ãƒ¼ãƒ çµ‚äº†åˆ¤å®š
            if (!hasLegalMoves) {
                if (kingInCheck) {
                    // ãƒã‚§ãƒƒã‚¯ãƒ¡ã‚¤ãƒˆ
                    gameStatus = 'checkmate';
                    updateMessage(`ğŸ’¥ ãƒã‚§ãƒƒã‚¯ãƒ¡ã‚¤ãƒˆï¼ ${opponent}ã®å‹ã¡ã§ã™ã€‚`, true);
                } else {
                    // ã‚¹ãƒ†ã‚¤ãƒ«ãƒ¡ã‚¤ãƒˆï¼ˆå¼•ãåˆ†ã‘ï¼‰
                    gameStatus = 'stalemate';
                    updateMessage('ğŸ¤ ã‚¹ãƒ†ã‚¤ãƒ«ãƒ¡ã‚¤ãƒˆï¼ å¼•ãåˆ†ã‘ã§ã™ã€‚', true);
                }
            } 
            // 3. ãã®ä»–å¼•ãåˆ†ã‘åˆ¤å®š
            else if (halfMoveClock >= 100) { // 50æ‰‹ãƒ«ãƒ¼ãƒ« (100ãƒãƒ¼ãƒ•ãƒ ãƒ¼ãƒ–)
                gameStatus = 'draw';
                updateMessage('â³ 50æ‰‹ãƒ«ãƒ¼ãƒ«ã«ã‚ˆã‚Šå¼•ãåˆ†ã‘ã§ã™ã€‚ (ãƒãƒ¼ãƒ³ã®ç§»å‹•ãƒ»ã‚­ãƒ£ãƒ—ãƒãƒ£ãªã—)', true);
            } 
            else if (fenHistory[generateFen()] >= 3) {
                gameStatus = 'draw';
                updateMessage('ğŸ” ã‚¹ãƒªãƒ¼ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ãƒ»ãƒªãƒ”ãƒ†ã‚£ã‚·ãƒ§ãƒ³ï¼ˆåŒä¸€å±€é¢3å›ï¼‰ã«ã‚ˆã‚Šå¼•ãåˆ†ã‘ã§ã™ã€‚', true);
            }
            // 4. é€šå¸¸ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            else if (kingInCheck) {
                // å˜ãªã‚‹ãƒã‚§ãƒƒã‚¯
                updateMessage(`ğŸš¨ ãƒã‚§ãƒƒã‚¯ï¼ ${currentPlayer === 'white' ? 'ç™½' : 'é»’'}ã®ã‚­ãƒ³ã‚°ãŒãƒã‚§ãƒƒã‚¯ã•ã‚Œã¦ã„ã¾ã™ï¼`, false, true);
            } else {
                // é€šå¸¸ã®æ‰‹ç•ªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                updateMessage(`${currentPlayer === 'white' ? 'ç™½' : 'é»’'}ã®æ‰‹ç•ªã§ã™ã€‚`);
            }
        }

        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹
        window.onload = initializeBoard;
    </script>
</head>
<body class="bg-gray-100 p-4 sm:p-8">
    <div class="container-wrapper">
        <h1 class="text-3xl font-extrabold text-gray-800 mb-6 rounded-lg p-2 bg-white shadow-lg w-full text-center">
            ãƒã‚§ã‚¹ã‚²ãƒ¼ãƒ  (å®Œå…¨ãƒ«ãƒ¼ãƒ«)
        </h1>
        
        <!-- ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœãƒƒã‚¯ã‚¹ -->
        <div id="message-box" class="shadow-lg"></div>

        <!-- ç›¤é¢ã‚³ãƒ³ãƒ†ãƒŠ -->
        <div class="chessboard-container">
            <div id="chessboard" class="board">
                <!-- ç›¤é¢ã¯JSã§æç”»ã•ã‚Œã¾ã™ -->
            </div>
        </div>

        <!-- ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ -->
        <button onclick="initializeBoard();"
                class="mt-6 px-6 py-2 bg-indigo-600 text-white font-bold rounded-full shadow-lg hover:bg-indigo-700 transition duration-300 transform hover:scale-105">
            ã‚²ãƒ¼ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆ
        </button>
        <p class="text-sm text-gray-500 mt-4 text-center">
            â€» ã‚­ãƒ£ã‚¹ãƒªãƒ³ã‚°ã€ã‚¢ãƒ³ãƒ‘ãƒƒã‚µãƒ³ã€ãƒ—ãƒ­ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆã‚¯ã‚¤ãƒ¼ãƒ³ã€ãƒ«ãƒ¼ã‚¯ã€ãƒ“ã‚·ãƒ§ãƒƒãƒ—ã€ãƒŠã‚¤ãƒˆï¼‰ã‚’å®Ÿè£…ã€‚
            50æ‰‹ãƒ«ãƒ¼ãƒ«ã¨ã‚¹ãƒªãƒ¼ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ãƒ»ãƒªãƒ”ãƒ†ã‚£ã‚·ãƒ§ãƒ³ã‚‚åˆ¤å®šã•ã‚Œã¾ã™ã€‚
        </p>
    </div>

    <!-- ãƒãƒ¼ãƒ³ãƒ—ãƒ­ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="promotion-modal" style="display: none;">
        <div class="promotion-content">
            <h2 class="text-xl font-bold mb-4 text-gray-800">é§’ã®æ˜‡æ ¼ (Promotion)</h2>
            <p class="mb-4">ã©ã®é§’ã«æ˜‡æ ¼ã—ã¾ã™ã‹ï¼Ÿ</p>
            <div id="promotion-options" class="flex justify-center">
                <!-- ãƒœã‚¿ãƒ³ã¯JSã§æŒ¿å…¥ã•ã‚Œã¾ã™ -->
            </div>
        </div>
    </div>
</body>
</html>
